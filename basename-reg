#!/usr/bin/env python
"""
basename-reg: split filename from known extensions

current impl. allows concatenation of var. tags, known and unknown 

todo should determine which tag identifies current format
other tags may participate in format, or not

ie. mysql.bz2
or tar.gz

::

	runtime:
		file -> basename, *ext

		*ext-type -> enum( archive, compression, format )

	storage:
		ext-reg: 
			ext -> mime
		ext-map: 
			ext -> ext
		multi:
			ext -> *ext
		xref:
			mime -> *ext, mtype, descr
		wild xref:
			mime -> *ext, descr
			ext -> *mime

"""
import os
import optparse
import inspect

import yaml

import lib

TODO_REG = {
		'py': "Python source script",
		'pyc': "Compiled Python script",
		'rst': "Restructuredtext document",
		'sh': "Shell script",
		'htm': "HTML document",
		'html': "HTML document",
		'xm': "eXtended Module Tracker music document",
		'js': "Javascript script",
		'exe': "MS executable",
		'zip': "ZIP compressed file archive",
		'csv': "Comma-Separated Values",
		'iso': "CD-ROM Image in ISO 9660 format",
		'bz2': "Bzip2 compressed file",
		'it': "Impuse Tracker music document",
		'tar': "Unix file archive",
		'gz': 'Gzip compressed file',
		'dmg': 'Mac OS Image',
		'rc': 'Executable configuration',
		'ini': 'MS-DOS-style Static configuration',
		'pdf': 'Portable Document Format',
		'pde': 'Processing Development Environment source file',
		'ino': 'Arduino C++ source file',
		'jar': 'Oracle Sun JAVA archive file',
		'mod': 'Module Tracker music document',
		'doc': 'MS Word document',
		'part': 'Partial download',
		'hex': 'Binary image file in HEX format',
		'c': 'C source-code file',
		'docx': 'ZIP Compressed MS Word XML file archive',
		'xlsx': 'ZIP Compressed MS Excel XML file archive',
		'jpg': 'Joint Photographic Expert Group',
		'nbm': 'Netbeans Plugin',
		'xml': 'eXtensible Markup Language',
		'skp': 'Sketchup Drawing',
		's3m': 'Scream Tracker 2 tracker module music file',
		'rb': 'Ruby source file',
		'rar': 'RAR compressed file archive',
	}


CONFIG = '~/.basename-reg.yaml'
conf = None
fullname = None

def get_config():
	global conf, fullname
	fullname = os.path.expanduser(CONFIG)
	conf = yaml.load(open(fullname))
	if conf == CONFIG:
		print "Failed loding config. "
	elif not conf:
		conf = {}

	if 'file_ext' not in conf:
		conf['ext_map'] = {}
		conf['ext_reg'] = {}
		conf['multi'] = {}
		conf['xref'] = {}
		conf['wxref'] = {}
		conf['ftype'] = []
		save_config()

def save_config():
	global conf, fullname
	fl = open(fullname, 'rw+')
	yaml.dump(conf, fl)
	fl.close()


class BasenameOut:
	"""Quick and dirty facade to handle output formatting. """
	emitters = dict(
		emit_known_extension = ('argument basename extension mime exts ftype description'.split(' ')),
		emit_new_extension_known_mime = ('argument basename extension mime exts ftype description'.split(' ')),
		emit_mime_detect = ('argument basename extension mime description exts'.split(' '))
	)
	def __init__(self, opts, stdout, stderr):
		self.stdout = stdout
		self.stderr = stderr
		self.templates = {}
		self.opts = opts
		fmt = opts.output_format
		#self.err("Output format %s" % fmt)
		if fmt == 'rst':
			self.init_rst_out()
		elif fmt == 'tab':
			self.init_fields_out('\t', opts.quote)
		elif fmt == 'csv':
			self.init_fields_out(opts.field_separator, opts.quote)
		elif fmt == 'brief':
			self.init_brief_out()
	def init_brief_out(self):
		self.templates['emit_mime_detect'] = "%(basename)s"
	def init_rst_out(self):
		self.templates['emit_mime_detect'] = ""
	def init_fields_out(self, sep, quote):
		opts = self.opts
		t = quote and '"%%(%s)s"' or "%%(%s)s"
		# XXX: override emitters from command-line (static), perhaps always send all
		# fields to emitter and decide wether to print later, on _emit.
		#if self.opts.output_format == 'tab':
#		self.emitters['emit_known_extension'] = ["mime", "ext"]#.split(' ')
		for emitter, fields in self.emitters.items():
			to_format = fields
			#if opts.brief and 'basename' in fields:
			#	to_format = ["basename"]
#			if opts.mime:
#				if 'mimes' in fields and 'mimes' not in to_format:
#					to_format.append('mimes')
#				if 'mime' in fields and 'mime' not in to_format:
#					to_format.append('mime')
#			if opts.extension:
#				if 'exts' in fields and 'exts' not in to_format:
#					to_format.append('exts')
#				if 'ext' in fields and 'ext' not in to_format:
#					to_format.append('ext')
			self.templates[emitter] = sep.join([ t % f for f in to_format ])
			print emitter, self.templates[emitter]
			setattr(self, emitter, self.emitter(emitter, fields))
	def err(self, out):
		if out:
			print >> self.stderr, out
	def emitter(self,emitter, fields):
		def _emit(*values):
			mapping = dict(zip( fields, values )) 
			if self.opts.print_header:
				print "#", ", ".join(fields)
			if 'exts' in mapping:
				mapping['exts'] = self.opts.ext_sep.join(mapping['exts'])
			if 'mimes' in mapping:
				mapping['mimes'] = self.opts.mime_sep.join(mapping['mimes'])
			lineout = self.templates[emitter] % mapping
			if lineout:
				print >>self.stdout, lineout
		return _emit


### Options

usage_descr = """%prog [-bem] [options] [file1...]"""

def optparse_bool(option, optstr, value, parser, new_value):
	parsed_value = new_value.lower() in "1 y yes true on".split(' ')
	#new_value.lower() in "0 n no false off".split(' ')
	setattr(parser.values, option.dest, new_value)

def optparse_output_format(option, optstr, value, parser, new_value):
#	if new_value == 'tab':
#		values.
	setattr(values, dest, value)


options_spec = (

	(('-i', '--interactive'), {'help':
		"", 'default': False, 'action': 'store_true' }),

	(( '--print-header', ), {'help':
		"", 'default': False, 'action': 'store_true' }),

# TODO: find a sane way to automatically add extensions
#	(('-a', '--'), {'help':
#		"Add unknown extension for known MIME. ", 'default': False }),
#	(('-A', '--'), {'help':
#		"Add unknown extension and MIME. Warning: this most certainly gives corrupt meta database. "
#		"Only use this for predictable, controlled data. ",
#		'default': False }),

	(('-O', '--output-format'), {'help':
		"Format for ouput, default is with csv"
		"seperated fields. Others: csv, rst. ",
#		'action': 'callback',
#		'callback': optparse_output_format,
		'default': 'tab'}),
	(('-F', '--field-separator'), {'help':
		"For CSV, this can provide an alternate separator to ','. "
		"Setting this for other formats has not effect",
		'default': ','}),
	(('--quote',), {'help':
		"The default is to quote all fields. ", 
#		'action': 'callback',
#		'callback': optparse_bool,
		'default': False
	}),
	(('--mime-sep',), {'help':
		"Set sub-field separator for multi mime types. ", 
		'default': ' '}),
	(('--ext-sep',), {'help':
		"Set sub-field separator for multi extensions. ", 
		'default': ','}),

	(('-b', '--brief'), {'help':
		"Reset field list to basename only. ", 
		'action': 'store_true',
		'default': False 
		}),
	(('-m', '--mime'), {'help':
		"List MIME types. ", 
		'action': 'store_true',
		'default': False }),
	(('-e', '--extension'), {'help':
		"List extensions. ", 
		'action': 'store_true',
		'default': False }),

#	(('-B', ), {'help':
#		"Remove basename from output fields. ", 'default': False }),
)


### Main

def main(argv, stdout, stderr):
	global conf
	root = os.getcwd()

	if not argv:
		argv = ['-h']

	prsr = optparse.OptionParser(usage=usage_descr)
	for a,k in options_spec:
		prsr.add_option(*a, **k)
	opts, args = prsr.parse_args(argv)

	get_config()

	out = BasenameOut(opts, stdout, stderr)

	ftypes = [ t.title() for t in conf['ftype'] ]

	store_mime = None
	for a in args:
		n = a
		# look for names with '.' separated fields 
		if '.' not in a:
			out.err('Ignored %s' % a)
			continue

		"""
		name_parts, candidates = scan_fields(a, opts)

		unknown = []
		for ext in extensions:
			if known(ext, opts):
				pass
			else:
				unknown.append(ext)

		if unknown:
			if opts.interactive:
				try_magic(a, opts)
			elif not opts.quiet:
				out.err("Error: unknown extensions: .%s" % '.'.join(exts))
"""
		# treat each field after first as potential tag, start with last
		name_parts = a.lower().split('.')[1:][::-1]
		for e in name_parts:
			if not e.strip():
				continue
			# strip file
			# FIXME: this does not replace uppercase tags yet
			# translate tag andlookup tag in registry
			ce = e
			if ce in conf['ext_map']:
				while ce in conf['ext_map']:
					ce = conf['ext_map'][ce]
			# replace last occurence of tag '.e'
			n = "".join(n.rsplit('.'+e, 1))

			if ce != e:
				out.err("Error: non-canonical extension, rename required. ")
				continue

			if ce in conf['ext_reg']:
				# found it, print continue
				mime = conf['ext_reg'][ce]
				exts, ftype, descr = conf['xref'][mime]
				out.emit_known_extension(a, n, ce, mime, exts, ftype, descr)

			elif not os.path.exists(a):
				out.err("Not a real file, cannot detect MIME: %s" % a)
				continue
			else:
				# look for mime
				mime = lib.cmd("file -bi %r" % a).strip()
				if mime in conf['xref']:
					# ok, have a mime, ask later wether to use it for ext
					exts, ftype, descr = conf['xref'][mime]
					out.emit_new_extension_known_mime(a, n, ce, mime, exts, ftype, descr)
				elif not opts.interactive:
					out.err("New MIME %r" % mime)
					continue
				elif store_mime != 'a':
					descr = lib.cmd("file -bs %r" % a).strip()
					exts = [ce]
					out.emit_mime_detect(a, n, ce, mime, descr, exts)
					qopts = list(conf['ftype']) + ['sKip', 'None']
					store_mime = lib.Prompt.query("New MIME: Give type or skip (all)", qopts)
					if store_mime >= len(ftypes):
						continue
					else:
						# XXX: should have loop while fields are updated
						mime = lib.Prompt.input("Use MIME? ", mime)
						descr = lib.Prompt.input("Use description? ", descr)
						ftype = ftypes[store_mime]
						conf['xref'][mime] = [exts, ftype, descr]
						save_config()
				else:
					assert False
				if e in exts:
					if exts[0] != e:
						cext = ext[0]
					else:
						cext = e
				else:
					assert e == ce, (e, ce)
					# FIXME
					cext = lib.Prompt.input("Register which? %s" % mime, ce)

				if cext in conf['ext_reg']:
					mime2 = conf['ext_reg'][cext]
					if mime != mime2:
						out.err("Error: Conflicting mime %r" % mime)
				else:
					v = lib.Prompt.ask("Store new extension? %r: %s [%s]" %
							(exts, descr, mime), "yN")
					print v
					if v:
						conf['ext_reg'][cext] = mime
						save_config()
					else:
						continue


if __name__ == '__main__':
	import sys
	sys.exit(main(sys.argv[1:], sys.stdout, sys.stderr))

"""
TODO: test

$ basename-reg -O=rst '/Volume/Disk/Folder/File name.sql.bz2'

:folder: /Volume/Disk/Folder
:basename: File Name
:format: BZip2 compressed MySQL script
:mediatype: mime1, mime2

$ basename-reg -c key value
$ basename-reg -R reg:ext:mime mime
$ basename-reg -R reg:ext:type type

$ basename-reg --sync-to-wild
# Update wild-xref index from local 

"""
