"""
Output handling using Zope adapters.

TODO: create various output adapters for various formats 
"""
#import sys, codecs, locale
#print locale.getpreferredencoding()
#print sys.stdout.encoding
#print str(sys.stdout.encoding)
#sys.stdout = codecs.getwriter('UTF-8')(sys.stdout);
#print str(sys.stdout.encoding)

import zope.interface
from zope.interface.interface import adapter_hooks
from zope.interface.adapter import AdapterRegistry

#import taxus
#import libcmd

registry = AdapterRegistry()

# generic types for stored object
class IID(zope.interface.Interface): pass
class IPrimitive(zope.interface.Interface): pass
class INode(zope.interface.Interface): pass
class INodeSet(zope.interface.Interface):
    nodes = zope.interface.Attribute("The list of nodes. ")

# output media types
class IFormatted(zope.interface.Interface):
    """
    The serialized representation of another object.
    """
#class ISerialized(IFormatted):
#    """
#    The formatted object of an ISerializable, which may be deserialized.
#    Otherwise use IFormatted.
#    """
# XXX: unused
#class IInteractive(IFormatted):
#    """
#    The interactive interface implicates that besides serialization,
#    there is an interactive action-response part to the representation.
#
#    The interaction usually consists of making choices or entering values.
#    Ofcourse the selection of sensible defaults makes for the best 
#    UX, but interaction is nevertheless not always avoidable.
#
#    This interface is used to declare wether a target requires some external
#    system or user interaction for successful completion, and to anticipate
#    the situation where such target is required. A common method is to 
#    load settings from the configuration, and let in this way personal
#    preference take out a lot of the interactive settings of a target.
#    """

# on line (retrievable) and cachable types
class IResource(zope.interface.Interface):
    """
    Something that is identified by a Universal Resource Indicator.

    Note the implication of RESTful architecture in the semantics (I'm not sure 
    how URN even fits into that?!).

    A Resource, in taxus/sqlalchemy, is split into Variant resources
    and Invariant resources. Invariants are those with an immutable bytestream
    representation of its entity (regardless of transport codecs).
    Variants are the abstract counterparts of invariants that have no single but 
    several or a multitude of bytestreams that in most cases are generated by a 
    server side script. In the case of RDF and other symbolic use of URIRefs, 
    there may be no IVariant or Invariant because the vendor does not publish
    anything at these URL's. Even though this is recommended practice.

    Generally when dealing with URL's, these are below 2000 characters for a
    good deal of the software. However no RFC has set a bound, other than that
    the server is responsible for the URL length [RFC 2616]. Generally the given
    bound is safe accross desktop and other modern web browsers. Because URL's
    may be far smaller or larger, a few classes of identifiers emerge.
    
    The smallest URL's fit in less than 20 bytes, it takes just 7 characters
    plus the hostname. For many URL shorteners, just over 20 bytes is enough to
    serve legions. Class A is anything up to 25 characters.

    Note that URL shortening may be beficial for high volume, it is a 
    flawed technical practice. It is suceptible to link-rot. The sites are
    fairly dumb, increasing spammer interest, adding to more link rot because
    of site shutdowns, etc.

    The largest URLs might be from systems with very big forms, but may also 
    be embedded scripts such as in the ``javascript:`` scheme. In bookmarklets,
    these easily reach thousands of characters for some modest but coherent 
    client functions.
    """

class IPersisted(IResource):
    """
    XXX: figure out interface methods/properties or related interfaces.

    IResource may be interactive and/or multipart aggregate resources.
    Ie. an IResource may consist of or contain other IResource instances, 
    build dynamically during or for a communication session.

    These are Variant resources meaning their format can change and their
    content is a derivative; it may have other representations, and may be opaque,
    or publicize an internal schema somehow.

    Non-variant resources are fixed bytestreams of which only the envelope
    changes (ie. the transmission encoding(s), parent archive or non-file storage 
    location). These types may implement IPersisted.
    """

# /xxx

def cn(obj):
    return obj.__class__.__name__


class PrimitiveFormatter(object):
    """
    Adapter
    """
    zope.interface.implements(IFormatted)
    __used_for__ = INode

    def __init__(self, context):
        self.context = context

    def toString(self):
        if isinstance(self.context, unicode) or isinstance(self.context, str):
            return self.context
        else:
            return str(self.context)

    def __str__(self, indent=0):
        return str(self.context)

    def __unicode__(self, indent=0):
        return unicode(self.context)

class IDFormatter(object):
    """
    Adapter
    """
    zope.interface.implements(IFormatted)
    __used_for__ = IID

    def __init__(self, context):
        self.context = context

    def __str__(self, indent=0):
        ctx = self.context
        import taxus
        if hasattr(ctx, 'name'):
            return "<urn:com.dotmpe:%s>"%str(ctx.name)
        elif isinstance(ctx, taxus.Locator):
            return "<%s>"%(ctx.ref)

class NodeFormatter(object):
    """
    Adapter
    """
    zope.interface.implements(IFormatted)
    __used_for__ = INode

    def __init__(self, context):
        self.context = context

    def __str__(self, indent=0):
        ctx = self.context
        indentstr = "".join('  ' * indent)
        fields = [
            indentstr+"%s: %s" % (k.key, IFormatted(getattr(ctx,
                k.key)).__str__(indent+1)) 
            #"%s: %s" % (k.key, getattr(ctx, k.key)) 
            for k in ctx.__mapper__.iterate_properties
            if not k.key.endswith('id')]
        #header = "%s <%s>" % ( cn(ctx), ctx.id )
        header = "Node <%s>" % ( ctx.id ,)
        return "[%s\n\t%s]" % (header, '\n\t'.join(fields))


class NodeSetFormatter(object):
    """
    Adapter
    """
    zope.interface.implements(IFormatted)
    __used_for__ = INodeSet
    def __init__(self, context):
        self.context = context
    def __str__(self, indent=0):
        strbuf = ""
        for node in self.context.nodes:
            strbuf += IFormatted(node).__str__(indent+1) + '\n'
        return strbuf

from datetime import datetime

zope.interface.classImplements(str, IPrimitive)
zope.interface.classImplements(unicode, IPrimitive)
zope.interface.classImplements(int, IPrimitive)
#zope.interface.classImplements(dict, IPrimitive)
zope.interface.classImplements(list, IPrimitive)

zope.interface.classImplements(datetime, IPrimitive)

registry.register([IID], IFormatted, '', IDFormatter)
registry.register([IPrimitive], IFormatted, '', PrimitiveFormatter)

registry.register([INodeSet], IFormatted, '', NodeSetFormatter)
registry.register([INode], IFormatted, '', NodeFormatter)

def hook(provided, object):
    if object == None:
        return PrimitiveFormatter(None)
    adapted = zope.interface.providedBy(object)
    #libcmd.err("Adapting %s:%s", object, adapted)
    adapter = registry.lookup1(
            adapted, provided, '')
    if not adapter:
        import sys
        #libcmd.err("Could not adapt %s:%s > %s", object, adapted, provided)
        print >>sys.stderr, "Could not adapt %s:%s > %s" %(object, adapted, provided)
    return adapter(object)

adapter_hooks.append(hook)

