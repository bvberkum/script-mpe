#!/bin/sh
c_source=$_

# Htdocs: work in progress 'daily' shell scripts

# Id: script.mpe/0.0.0+20150911-0659 htd


set -e

version=0.0.0+20150911-0659 # script.mpe


htd_load()
{
  # -- htd box load insert sentinel --
  test -n "$UCONFDIR" || UCONFDIR=$HOME/.conf/
  [ -n "$HTDIR" ] || HTDIR=$HOME/public_html
  [ -n "$CWDIR" ] || CWDIR=
  [ -n "$EDITOR" ] || EDITOR=vim
  [ -n "$HTD_GIT_REMOTE" ] || HTD_GIT_REMOTE=default
  # TODO look in registry for PROJECT
  [ -n "$PROJECT" ] || PROJECT="$(basename $(pwd))"
  _14MB=14680064
  _6MB=7397376
  _5k=5120
  test -n "$MIN_SIZE" || MIN_SIZE=$_6MB

  test -n "$hostname" || hostname="$(hostname -s | tr 'A-Z' 'a-z')"
  test -n "$uname" || uname="$(uname -s)"

  cwd=$(pwd)
  test "$cwd" = "$(pwd -P)" || warn "current path seems to be aliased"

  test -e table.sha1 && R_C_SHA3="$(cat table.sha1|wc -l)"

  stdio_type 0
  test "$stdio_0_type" = "t" && {
    rows=$(stty size|awk '{print $1}')
    cols=$(stty size|awk '{print $2}')
  } || {
    rows=32
    cols=79
  }

  HTD_IGNORE=.htdignore
  test -e .git && {
    printf ""
    # FIXME: .htdignore ignore..
    #grep $HTD_IGNORE .gitignore > /dev/null || {
    #  echo $HTD_IGNORE >> .gitignore
    #}
  }
  htd_init_ignores
  {
    find_ignores=""$(echo $(cat $HTD_IGNORE.merged | \
      grep -Ev '^(#.*|\s*)$' | \
      sed -E 's/^\//\.\//' | \
      sed -E 's/(.*)/ -o -name "\1" -prune /g'))
    find_ignores="-path \"*/.git\" -prune $find_ignores "
  } || error "foo bar" 1
  #match_load_table vars

  which -s tmux || {
    export PATH=/usr/local/bin:$PATH
  }

  which -s rst2xml && rst2xml=$(which rst2xml) \
    || which -s rst2xml.py && rst2xml=$(which rst2xml.py) \
    || error "No rst2xml"
}

htd_usage()
{
  echo "$scriptname.sh Bash/Shell script helper"
  echo 'Usage: '
  echo "  $scriptname <cmd> [<args>..]"
}

htd_commands()
{
  echo 'Commands: '
  echo '  home                             Print htd dir.'
  echo '  info                             Print vars.'
  echo '  mk|make                          Run make (in htd dir).'
  echo '  st|stat                          Run make stat.'
  echo '  sys                              Run make sys.'
  echo '  vt|vtoday                        Run make vtoday.'
  echo '  today [<prefix> [<ext>]]         Create symlinks of the format $PREFIX/{today,tomorrow,yesterday}.rst -> %Y-%m-%d.rst'
  echo ''
  echo 'Virtuals: '
  echo '  vbox-start <name>                Start headless VBoxVM for VM UUID with name in VBoxVM table. '
  echo '  vbox-suspend <name>              Suspend VBoxVM. '
  echo '  vbox-reset <name>                Reboot VBoxVM. '
  echo '  vbox-stop <name>                 Stop VBoxVM. '
  echo '  vbox-list                        List known and unknown VMs. '
  echo '  vbox-running                     List running VMs. '
  echo '  vbox-info [<name>]'
  echo ''
  echo '  lists [opts]                     List all lists. '
  echo '  tasks [<list>..]                 List tasks in lists'
  echo '  new-task <list> <title>          Add task to list with title'
  echo '  task-note <list> <num>           Edit notes of task in the $EDITOR'
  echo '  task-title <list> <num> [<title>]'
  echo '                                   Get or update title of task'
  echo '  done <list> <num>                Toggle task completed status'
  echo '  todo                             '
  echo ''
  echo 'Networking'
  echo '  wol <host>                       Send wol to mac for host from WOL table.'
  echo '  mac                              List ARP table: hwaddr for clients (once) connector to LAN. '
  echo ''
  echo 'File Versioning'
  echo '  git-remote [repo]                List all names remotely, or give the SSH url for given repo. '
  echo '  git-init-remote [repo]           Initialze remote bare repo if local path is GIT project'
  echo '  git-remote-info                  Show current ~/.conf/git-remotes/* vars.'
  echo '  git-largest-objects (10)         List the SHA1 sums of the largest objects.'
  echo '  git-path-for-object <sha1>       Given SHA1 object, find its current path.'
  echo '  git-annex-unused                 Show keys of stored objects without path using them. '
  echo '  git-annex-show-unused            Show commit logs for unused keys. '
  echo '  git-annex-clear-unused [<to>]    Drop the unused keys, or move to remote. '
  echo ''
  echo 'Working tree utils'
  echo '  check-names [. [<tags>]]         Check names in path, according to tags.'
  echo '  list-paths [.|<dirpath]          List all paths below, including dirs. '
  echo '  test-name <path>                 Test filename for unhandled characters. '
  echo '  find-name <path|localname>       TODO: Given (partial) path, try to find the file using find.  '
  echo '  update                           Fill checksums tables for all local files. TODO: find out what there is to know about file using settings, other commands, ext. tooling & services. And trigger resolve'
  echo '  fix-names [.|<dirpath]           checks files against name patterns'
  echo '  '
  echo 'Rules'
  echo '  resolve                          XXX based on data and settings, pre-process and mark all files ready for commit, and bail on any irregularities. '
  echo '  commit                           XXX record metadata according to htd settings/commands. Commit is only a success, if the entire tree is either clean or ignored. '
  echo '  show-rules [<path>]              tabulate all rules that would apply to path'
    echo '  run-rules [<path>]               (re-)run rules on path'
  echo '  add-rule <pattern> <functions>|<script> '
  echo '                                   Add either function and inline script to run for every path matching pattern. '
  echo ''
  echo 'Working tree metadata'
  echo '  ck-consolidate [.|<path>]        TODO: integrate metadata from all metafiles (see ck-metafile)'
  echo '  ck-metafile <path>               TODO: integrate metadata from .meta/.rst/.sha1sum/etc. '
  echo ''
  echo 'Working tree checksum metadata [CK_TABLE=./]'
  echo '  ck-update [ck|md5|sha1] (<path>)  Iterate all files, and create checksum table records for unknown files. '
  echo "  ck-table [ck|md5|sha1] <path>    Tell if checksum exists for file, don\'t validate or update. "
  echo '  ck-table-subtree [ck|md5|sha1] <path> '
  echo '                                   Like ck-table, but this takes a partial path starting at the root level and returns the checksum records for files below that. '
  echo '  ck-drop [ck|mk5|sha1] <path>     Remove row for given path from checksum table. '
  echo '  ck-validate [ck|md5|sha1]        Verify each file by generating and comparing its checksum. '
  echo '  ck-check [ck|md5|sha1]           Iterate table, move lines with non-existant paths to .missing table'
  echo '  ck-fix [.|<path>]                If path exists, look for duplicates using ck-find-content and move this path to .duplicates marking it to be resolved interactively. '
  echo '                                   Or if path is missing, try find-name to find new location. If still missing, look for any copy using ck-find-content and move current entry to table .duplicate on success, or .gone on failure. '
  echo '  ck-check-missing [ck|md5|sha1]   TODO: iterate .missing table, and call ck-fix. Move checksum to .gone if file stays missing. '
  echo '  ck-clean [ck|md5|sha1]           TODO: iterate .gone table, and call ck-fix. Move gone checksum if file stays missing. '
  echo '  ck-purge [|missing|duplicate|gone] TODO: drop missing-paths from indicate tables. '
  echo '  ck-dedup <path>                  With no path given, iterate the duplicate table. Otherwise deduplicate content, using given path as preferred location. '
  echo '  ck-find-content <path>           Given path, try find-name or checksum tables and annex-backend to find copies and give all alternate locations. '
  echo ''
  echo 'Other commands: '
  other_cmds
}
other_cmds()
{
  echo '  -E|edit-main                     Edit this script.'
  echo '  -e|edit                          Edit a local document or script.'
  echo '  alias                            Show bash aliases for this script.'
  echo '  -h|help                          Give a combined usage, command and docs. '
  echo '  docs                             Echo manual page. '
  echo '  commands                         Echo this comand description listing.'
  echo "  usage                            List all commands. "
  echo "  info                             List env info. "
  echo "  files                            List file used by htd. "
  echo '  mk|make                          Run make (in htd dir).'
  echo '  vt|vtoday                        Run make vtoday.'
}

c_docs()
{
  echo "Docs:" 
  echo ""
}

c_files()
{
  echo "Files"
  echo ""
  echo "    From config settings:"
  echo "  $vbox_names (\$vbox_names)"
  echo "  $wol_hwaddr (\$wol_hwaddr)"
  echo ""
  echo "    From CWD:"
  echo "  ./TODO.list"
  echo "  ./table.names"
  echo "  ./invalid.paths"
  echo "    TODO: uses path .git/.."
  echo "    TODO: paths used by matchbox"
  echo ""
  echo "    Temporary left after exec:"
  echo "  /tmp/gtasks-\$list-\$num-note"
  echo ""
  echo "    Config files"
  echo "  ~/.conf/git-remotes/\$HTD_GIT_REMOTE.sh"
  echo "  ~/.conf/rules/\$host/\$project.sh"
  echo ''
  echo 'See dckr for container commands and vc for GIT related. '
}

c_man_1_commands="List all commands"
c_commands()
{
  choice_global= choice_all=true std_commands
}


c_man_1_help="Echo a combined usage, command and docs"
c_spc_help="-h|help [<id>]"
c_help()
{
  test -z "$1" && {
    htd_usage
    echo ''
    echo 'Main commands: '
    other_cmds
  } || {
    echo_help $1
  }
}
c_als__h=help
c__h()
{
  cmd=help c_help $@
}


c_man_1_version="Version info"
c_version()
{
  echo "$(cat $PREFIX/bin/.app-id)/$version"
}
c_als__V=version


c_home()
{
  echo $HTDIR
}

c_info()
{
  echo "env"
  echo "  CWDIR"
  echo "    If set, use instead of the current directory for working dir. "
  echo ""
  log "Script:                '$(pwd)/$scriptname'"
  log "User Config Dir:       '$UCONFDIR' [UCONFDIR]"
  log "User Public HTML Dir:  '$HTDIR' [HTDIR]"
  log "Current workingdir:    '$CWDIR' [CWDIR]"
  log "Project ID:            '$PROJECT' [PROJECT]"
  log "Minimum filesize:      '$(( $MIN_SIZE / 1024 ))'"
  log "Editor:                '$EDITOR' [EDITOR]"
  log "Default GIT remote:    '$HTD_GIT_REMOTE' [HTD_GIT_REMOTE]"
  log "Ignored paths:         '$HTD_IGNORE' [HTD_IGNORE]"
}

c_expand()
{
  test -n "$1" || return 1
  for x in $1
  do
    test -e "$x" && echo $x
  done
}


c_man_1_edit_main="Edit the main script file"
c_spc_edit_main="-E|edit-main"
c_edit_main()
{
  locate_name
  [ -n "$fn" ] || error "expected $scriptname?" 1
  $EDITOR $fn "$@"
}
c_als__E=edit-main


c_man_1_edit="Edit a local file, or abort"
c_spc_edit="-e|edit <id>"
c_edit()
{
  test -n "$1" || error "TODO nothing to look for" 1
  doc_name_arg $1 $2
  doc_find
  test -e "$file" || error "Should have catched that" 1
  $EDITOR $file
}
c_als__e=edit


c_man_1_find="Look for doc"
c_spc_find="-f|find"
c_find()
{
  test -n "$1" || error "TODO nothing to look for" 1
  doc_name_arg $1 $2
  doc_list_all
}
c_als__f=find


htd_init_ignores()
{
  test -n "$HTD_IGNORE" || exit 1
  rm -f $HTD_IGNORE.merged
  for x in .git/info/exclude .gitignore $HTD_IGNORE
  do 
    test -s $x && {
      cat $x | grep -Ev '^(#.*|\s*)$' >> $HTD_IGNORE.merged
    }
  done
  echo $HTD_IGNORE.merged >> $HTD_IGNORE.merged
}

c_init_ignores()
{
  htd_init_ignores
}


req_path_arg()
{
  test -n "$1"  && path="$1"  || path=.
  test -d "$path" || {
    error "Must pass directory" 1
  }
}

htd_relative_path()
{
  cwd=$(pwd)
  test -e "$1" && {
    x_re "${1}" '\/.*' && {
      error "TODO make rel"
    }
    x_re "${1}" '[^\/].*' && {
      x_re "${1}" '((\.\/)|(\.\.)).*' && {
        relpath="${1: 2}"
      } || {
        relpath="$1"
      }
      return 0
    }
  }
  return 1
}

c_man_1_relative_path="Test for relative path"
c_relative_path()
{
  # TODO: maybe build relative path from 1 arg and cwd, or two args
  # see also mkrlink. Also clean up.
  #x_re "${1:0:2}" '[\.\/]*' && echo ok || echo nok
  htd_relative_path $1
  r=$?
  echo relpath=$relpath
  exit $r
}
c_man_1_relpath="Alias for 'relative-path'"
c_relpath()
{
  c_relative_path $1
}

# return paths for names that exist along given path
htd_find_path_locals()
{
    local name path stop_at
    name=$1
    path="$(cd $2;pwd)"
    test -z "$3" && stop_at= || stop_at="$(cd $3;pwd)"
    path_locals=
    while test -n "$path" -a "$path" != "/"
    do
        test -e "$path/$name" && {
            path_locals="$path_locals $path/$name"
        }
        test "$path" = "$stop_at" && {
            break
        }
        path=$(dirname $path)
    done
}

c_man_5_table_names=""

c_test_find_path_locals()
{
    htd_find_path_locals table.names $1
    echo path_locals=$path_locals

    htd_find_path_locals table.names $1 $(pwd)
    echo path_locals=$path_locals
}
# 
c_fsck()
{
  c_ck_validate sha1
}

c_make()
{
  cd $HTDIR && make $*
}
c_mk()
{
  c_make $*
}

# Run a sys-* target in the main htdocs dir.
c_make_sys()
{
  cd $HTDIR
  for x in $*
  do
    make system-$x
  done
}

c_stat()
{
  c_make stat
}

c_als_st=stat
c_st()
{
  cmd=stat c_stat $*
}

c_build()
{
  rm -f /tmp/htd-out
  c_make build 2>1 | capture_and_clear
  echo Mixed output::
  echo
  cat /tmp/htd-out | sed  's/^/    /'
}

# show htd shell aliases
c_alias()
{
  grep '\<'$scriptname'\>' ~/.alias | grep -Ev '^(#.*|\s*)$' | while read _a A
  do
    a_id=$(echo $A | awk -F '=' '{print $1}')
    a_shell=$(echo $A | awk -F '=' '{print $2}')
    echo -e "   $a_id     \t$a_shell"
  done
}

# Open an editor to edit todays log
c_vtoday()
{
  c_today personal/journal
  $EDITOR $personal/journal/{today,tomorrow,yesterday}.rst
  git add personal/journal/
}
c_als_vt=vtoday


# update yesterday, today and tomorrow links
c_today()
{
  test -z "$1" && P=journal || P=$1
  test -d "$P" || error "Dir $(pwd)/$P must exist" 1
  YSEP=/
  Y=%Y
  MSEP=-
  M=%m
  DSEP=-
  D=%d
  test -z "$EXT" && EXT=.rst || EXT=$EXT
  r=$P$YSEP
  p=$P$YSEP$Y$MSEP$M$DSEP$D$EXT
  datelink -1d "$p" ${r}yesterday$EXT
  datelink "" "$p" ${r}today$EXT
  datelink +1d "$p" ${r}tomorrow$EXT
  for tag in sunday monday tuesday wednesday thursday friday saturday
  do
    datelink "$tag -7d" "$p" "${r}last-$tag$EXT"
    datelink "$tag +7d" "$p" "${r}next-$tag$EXT"
    datelink "$tag" "$p" "${r}$tag$EXT"
  done
}


# TODO: move date routines to lib
# NOTE: these use BSD date -v, see GNU date -d
case "$(uname)" in Darwin )
    date_fmt() {
      tags=$(for tag in $1; do echo "-v $tag"; done)
      date $tags +$2
    }
    ;;
  Linux )
    date_fmt() {
      # NOTE patching for GNU date
      tags=$(for tag in $1; do echo "-d $tag" \
          | sed 's/1d/day/g' \
          | sed 's/7d/week/g'; done)
      date $tags +$2
    }
    ;;
esac

datelink()
{
  test -z "$1" && datep=$(date "+$2") || datep=$(date_fmt "$1" "$2")
  target_path=$3
  test -d "$(dirname $3)" || error "Dir $(dirname $3) must exist" 1
  test -L $target_path && {
    test "$(readlink $target_path)" = "$(basename $datep)" && {
        return
    }
    printf "Deleting "
    rm -v $target_path
  }
  mkrlink $datep $target_path
}

mkrlink()
{
  # TODO: find shortest relative path
  printf "Linking "
  ln -vs $(basename $1) $2
}


### VirtualBox

vbox_names=~/.conf/vbox/vms.sh
c_vbox()
{
  name=$1
  [ -z "$name" ] && {
    c_vbox_list
  } || {
    declare $(echo $(cat $vbox_names))
    uuid=$(eval echo \$$name)
    test -n "$uuid" || error "No such vbox VM '$name'" 1
  }
}

c_vbox_start()
{
  c_vbox $1
  VBoxManage startvm ${uuid} --type headless \
      || error "Headless-start of VM $name" 1 \
      && log "Headless-start of VM $name completed successfully"
}

c_vbox_start_console()
{
  c_vbox $1
  VBoxManage startvm ${uuid} \
      || error "Console-start of VM $name" 1 \
      && log "Console-start of VM $name completed successfully"
}

c_vbox_reset()
{
  c_vbox $1
  VBoxManage controlvm ${uuid} reset \
      || error "Reset of VM $name" 1 \
      && log "Reset of VM $name completed successfully"
}

c_vbox_stop()
{
  c_vbox $1
  VBoxManage controlvm ${uuid} poweroff \
      || error "Power-off of VM $name" 1 \
      && log "Power-off of VM $name completed successfully"
}

c_vbox_suspend()
{
  c_vbox $1
  VBoxManage controlvm ${uuid} savestate \
      || error "Save-state of VM $name" 1 \
      && log "Save-state of VM $name completed successfully"
}

c_vbox_list()
{
  VBoxManage list vms | \
    sed 's/^"\(.*\)"\ {\(.*\)}$/\2 \1/' | while read uuid name
  do
    grep $uuid $vbox_names >> /dev/null || echo unknown $name =$uuid
  done
  cat $vbox_names | \
    grep -Ev '^\s*(#.*|\s*)$'
}

c_vbox_running()
{
  VBoxManage list runningvms
}

c_vbox_info()
{
  test -n "$1" && {
    c_vbox $1
    #2: --details --machinereadable
    VBoxManage showvminfo ${uuid} $2
  } || {
      for sub in intnets bridgedifs hostonlyifs natnets dhcpservers
      do log "Showing $sub"; VBoxManage list $sub; done
  }
}

c_vbox_gp()
{
  c_vbox "$1"
  VBoxManage guestproperty enumerate ${uuid}
  #VBoxManage guestproperty get ${uuid} "/VirtualBox/GuestInfo/Net/0/V4/IP"
}


# Wake a remote host using its ethernet address
wol_hwaddr=~/.conf/wol/hosts-hwaddr.sh
c_wol_list_hosts()
{
  cat $wol_hwaddr
  error "Expected hostname argument" 2
}
c_wake()
{
  host=$1
  [ -z "$host" ] && {
    c_wol_list_hosts
  } || {
    declare $(echo $(cat $wol_hwaddr))
    hwaddr=$(eval echo \$$host)
    [ -n "$hwaddr" ] || exit 4
    wakeonlan $hwaddr
    echo ":WOL Host: \`$host <$hwaddr>\`_"
  }
}

# Simply list ARP-table, may want something better like arp-scan or an nmap
# script
c_mac()
{
  arp -a
}

# 

c_project()
{
  printf ""
}

c_project_todo()
{
  title=
  descr=
  refs=
}

# Experimenting with gtasks.. looking at todo targets
c_todo()
{
  test -e TODO.list && {
    cat TODO.list | \
      grep -Ev '^(#.*|\s*)$' | \
      while read line
      do
        todo_read_line "$line"
        todo_clean_descr "$comment"
        echo "$fn $ln  $tag  $descr"
        # (.,.)p
      done
  } || {
    echo
    echo "..Htdocs ToDo.."
    gtasks -L -dsc -dse -sn
    echo "Due:"
    gtasks -L -sdo -dse -sn
#  echo ""
#  gtasks -L -sb tomorrow -sa today -dse
  }
}

todo_clean_descr()
{
  echo "$@" | \
  grep -E '^.*(TODO|XXX|FIXME)[\ \:]*(.*)((\?\ )|(\.\ )|(\.\s*$)).*$' \
  > /dev/null && {
    clean=$( echo "$@" | \
      sed -E 's/^.*(TODO|XXX|FIXME)[\ \:]*(.*)((\?\ )|(\.\ )|(\.\s*$)).*$/\1 \2\3/' )
  } || {
    clean=$( echo "$@" | \
      sed -E 's/^.*(TODO|XXX|FIXME)[\ \:]*(.*)$/\1 \2/' )
  }
  tag=$(echo $clean|cut -f 1 -d ' ')
  descr="$(echo ${clean:$(( ${#tag} + 1 ))})"
  test -n "$descr" -a "$descr" != " " && {
    echo $descr | grep -E '(\.|\?)$' > /dev/null || {
      set --
      # TODO: scan lines for end...
    }
  }
}

todo_read_line()
{
  line="$1"
  fn=$(echo $line | cut -f 1 -d ':')
  ln=$(echo $line | cut -f 2 -d ':')
  test "$ln" -eq "$ln" 2> /dev/null \
    || error "Please include line-numbers in the TODO.list" 1
  comment=${line:$((  ${#fn} + ${#ln} + 2  ))}
}


htd_grep_line_exclude()
{
  grep -v '.*\ htd:ignore\s*'
  # TODO: build lookup util for ignored file line ranges
  #| while read line
  #do
  #    file=$()
  #    linenr=$()
  #    c_htd_excluded_line $file $linenr
  #done
}

c_man_1_build_todo_list="Build indented file of path/line/tag from FIXME: etc tagged
src files"
c_build_todo_list()
{
  test -n "$1" || set -- TODO.list "$2"
  test -n "$2" || {
    test -s .app-id \
        && set -- "$1" "$(cat .app-id)" \
        || set -- "$2" "$(basename $(pwd))"
  }

  { for tag in FIXME TODO NOTE XXX
  do
    grep -nsrI $tag':' . \
        | grep -v $1':' \
        | htd_grep_line_exclude \
        | while read line;
      do
        tid="$(echo $line | sed -n 's/.*'$tag':\([a-z0-9\.\+_-]*\):.*/\1/p')"
        test -z "$tid" \
            && echo "$(pwd);$2#$tag;$line" \
            || echo "$(pwd);$2#$tag:$tid;$line";

      done
  done; } | todo-meta.py import -

#  grep -nsrI '\(\<FIXME\|TODO\|NOTE\|XXX\>\):' . \
#      | grep -v '^#|\s*$' \
#      | grep -v '.*#\ htd:ignore\s*' \
#      | sort \
#      | sed 's/\:\([0-9]*\)\:[\s\#]*/:\
#\ \ \1\
#\ \ \ \ /g' > $1
}


# Lists and tasks

gtasks_list_arg()
{
    test -z "$1" && list=Standaardlijst || list="$1"
}
gtasks_num_arg()
{
    test -z "$1" && return 1 || num="$1"
}
gtasks_list_opt()
{
  test -z "$1" && {
    list="-l Standaardlijst"
  } || {
    test "${1:0:1}" = "-" && {
      # possibly use verbatim opts (-L)
      list="$1"
    } || {
      list="-l $1"
    }
  }
}
gtasks_opts()
{
  cnt=0
  gtasks_opts=
  while test "${1:0:1}" = "-"
  do
    gtasks_opts="$gtasks_opts $1"
    cnt=$(( $cnt + 1 ))
    shift 1
  done
  return $cnt
}

htd_file_arg()
{
  test -n "$1" && {
    file=$1
    shift 1
  } || return 1
}

# List all lists
c_lists()
{
  test -n "$gtasks_opts" || gtasks_opts="-dsc"
  gtasks -ll $gtasks_opts
}

# List tasks in lists
c_tasks()
{
  gtasks_opts $@
  shift $?
  test -n "$gtasks_opts" || gtasks_opts="-dsc"
  test -z "$1" && {
    gtasks_list_opt
    gtasks $list $gtasks_opts
  }
  while test -n "$1"
  do
    gtasks_list_opt $@ && shift 1
    gtasks $list $gtasks_opts
  done
}

# Add task to list with title
c_new_task()
{
  gtasks_list_arg $1 && shift 1
  gtasks -l "$list" -a - -t "$@"
}

# Edit notes of a task in the $EDITOR
c_task_note()
{
  gtasks_list_arg $1 && shift 1
  gtasks_num_arg $1 && shift 1 || exit 1
  tmpf=/tmp/gtasks-$list-$num-note
  title="$(gtasks -dsc -l "$list" -gt $num)"
  mkdir -p $(dirname $tmpf)
  gtasks -dsc -l "$list" -gn $num > $tmpf.current
  check_pre=$(md5sum $tmpf.current | cut -f 1 -d ' ')
  echo -e "$title\n" > $tmpf.txt
  cat $tmpf.current >> $tmpf.txt
  $EDITOR $tmpf.txt
  new_title=$(head -n 1 $tmpf.txt)
  tail -n +3 $tmpf.txt > $tmpf.new
  check=$(md5sum $tmpf.new | cut -f 1 -d ' ')
  test "$title" != "$new_title" && {
    printf "Updating title ... "
    gtasks -l "$list" -e $num -t "$new_title" -dsl
  } || {
    echo "No changes to title. "
  }
  test "$check_pre" != "$check" && {
    printf "Updating notes ... "
    gtasks -l "$list" -e $num -n "$(cat $tmpf.new)" -dsl
  } || {
    echo "No changes to notes. "
  }
}

# Get or updte title of task
c_task_title()
{
  gtasks_list_arg $1 && shift 1
  gtasks_num_arg $1 && shift 1 || exit 1
  test -z "$1" && {
    gtasks -dsc -l "$list" -gt $num
  } || {
    gtasks -dsc -l "$list" -e $num -t "$1"
  }
}

# Toggle task completed status
c_done()
{
  test -n "$2" && {
    test "$2" -gt 0 && {
      gtasks_list_arg $1 && shift 1
      gtasks_num_arg $1 && shift 1 || exit 1
    }
  } || {
    test -n "$1" -a "$1" -gt 0 && {
      # default list
      gtasks_list_arg
      gtasks_num_arg $1 && shift 1 || exit 1
    }
  }
  gtasks -dsc -l "$list" -c $num
}

# TODO: get references from file
c_urls()
{
  htd_file_arg $1 || exit 1
  shift 1
  grep '\([a-z]\+\):\/\/.*' $file | while read url
  do
    sha1=$(printf $url | sha1sum - | cut -d ' ' -f 1)
    md5=$(printf $url | md5sum - | cut -d ' ' -f 1)
    echo $sha1 $md5 $url
  done
}

# init or list SSH based remote 

source_git_remote()
{
  test -n "$1" || set -- "$HTD_GIT_REMOTE"
  . ~/.conf/git-remotes/$1.sh \
      || error "Missing 1=$1 script" 1
}

c_git_remote_info()
{
  test -n "$1" || set -- "$HTD_GIT_REMOTE"
  source_git_remote "$1"
  echo remote.$1.dir=$remote_dir
  echo remote.$1.host=$remote_host
  echo remote.$1.user=$remote_user
}
c_git_remote()
{
  test -n "$2" && {
    source_git_remote $1; shift 1
  } || source_git_remote

  [ -z "$1" ] && {
    ssh_cmd="cd $remote_dir; ls | grep '.*.git$' | sed 's/\.git$//g' "
    ssh $ssh_opts $remote_user@$remote_host "$ssh_cmd"
  } || {
    repo=$1
    #git_url="ssh://$remote_host/~$remote_user/$remote_dir/$repo.git"
    scp_url="$remote_user@$remote_host:$remote_dir/$repo.git"
    echo $scp_url
  }
}

c_git_init_remote()
{
  source_git_remote
  [ -n "$1" ] && repo="$1" || repo="$PROJECT"

  ssh_cmd="mkdir -v $remote_dir/$repo.git"
  ssh $remote_user@$remote_host "$ssh_cmd"

  [ -e .git ] || error "No .git directory, stopping remote init" 0

  c_git_remote $repo >> /dev/null

  BARE=../$repo.git
  TMP_BARE=1
  [ -d $BARE ] && TMP_BARE= || {
    [ -d /src/$repo.git ] && {
      TMP_BARE=
      BARE=/src/$repo.git
    } || {
      log "Creating temp. bare clone"
      git clone --bare . $BARE
    }
  }

  [ -n "$TMP_BARE" ] || {
    log "Using existing bare repository to init remote: $BARE"
  }

  log "Syning new bare repo to $scp_url"
  rsync -azu $BARE/ $scp_url
  [ -n "$TMP_BARE" ] && {
    log "Deleting temp. bare clone ($BARE)"
    rm -rf $BARE
  }

  log "Adding new remote, and fetching remote refs"
  git remote add $HTD_GIT_REMOTE $scp_url
  git fetch $HTD_GIT_REMOTE

  log "Added remote $HTD_GIT_REMOTE $scp_url"
}

c_git_drop_remote()
{
  [ -n "$1" ] && repo="$1" || repo="$PROJECT"
  log "Checking if repo exists.."
  ssh_opts=-q
  c_git_remote | grep $repo || {
    error "No such remote repo $repo" 1
  }
  source_git_remote
  log "Deleting remote repo $remote_user@$remote_host:$remote_dir/$repo"
  ssh_cmd="rm -rf $remote_dir/$repo.git"
  ssh -q $remote_user@$remote_host "$ssh_cmd"
  log "OK, $repo no longer exists"
}



# indexing, cleaning

htd_name_precaution() {
  echo "$1" | grep -E '^[]\[{}\(\)A-Za-z0-9\.,!@#&%*?:'\''\+\ \/_-]*$' > /dev/null || return 1
}

c_test_name()
{
  match_grep_pattern_test "$1" || return 1
  htd_name_precaution "$1" || return 1
  test "$cmd" = "test-name" && {
    echo 'name ok'
  }
  return 0
}

c_find_empty()
{
  eval find . $find_ignores -o -size 0 -a -print
}

c_filesize()
{
  filesize "$1"
}

# XXX: a function to clean directories
# TODO: hark back to statusdir?
# TODO: notice deprecation marks
c_check()
{
  log "Looking for unknown files.."

  pwd=$(pwd)
  cruft=/tmp/htd-$(echo $pwd|tr '/' '-')-cruft.list
  test ! -e "$cruft" || rm $cruft
  eval find . $find_ignores -o -print \
    | while read p
    do

      c_test_name "$p" >> /dev/null || {
        warn "Unhandled characters: $p"
        continue
      }

      [ -L "$p" ] && {
        BE="$(dirname "$p")/$(readlink "$p")"
        [ -e "$BE" ] || {
          warn "Skip dead symlink"
          continue
        }
        SZ="$(filesize "$BE")"
      } || {
        SZ="$(filesize "$p")"
      }

      if test -d "$p" -a -n "$(c_expand $p.{zip,tar{.gz,.bz2}})"
      then
        info "Skipping unpacked dir $p"
        for ck in ck sha1 md5
        do
          c_ck_table_subtree $ck "$p" | while read p2
          do
            c_ck_table $ck "$p2" > /dev/null && {
              #c_ck_drop $ck "$p"
              warn "FIXME: Dropped $ck key for $p"
            }
          done
        done
        continue
      fi

      test "$SZ" -ge "$MIN_SIZE" || {
        info "File too small: $p"
        echo $p >>$cruft
        continue
      }

    done

  test -s "$cruft" && {
    note "Cruft in $pwd: $(line_count $cruft) files"
  } || noop

}

htd_git_rename()
{
  $PREFIX/bin/matchbox.py rename "$1" "$2" |
  grep -Ev '^\s*(#.*|\s*)$' |
  while read file_old file_new
  do
    $cmd_pref git mv "$file_old" "$file_new"
  done
}

c_rename_test()
{
  cmd_pref="echo"
  c_rename $@
}

c_rename()
{
  from_pattern="$1"
  to_pattern="$2"
  #$(echo $2 | sed 's/@\([A-Z0-9_]*\)/${\1}/g')
  shift 2
  test -z "$1" && {
    htd_git_rename "$from_pattern" "$to_pattern"
  } || {
    { for p in $@; do echo $p; done ; echo -e "\l"; } |
    htd_git_rename "$from_pattern" "$to_pattern"
  }
}

# List all paths including dirs
c_list_paths()
{
  req_path_arg "$@"
  eval find $path $find_ignores -o -print
}

c_check_names()
{
  test -z "$1" && d="." || { d="$1"; shift 1; }
  test -z "$1" && valid_tags="" || valid_tags="$1"
  test "${d: -1:1}" = "/" && d="${d:0: -1}"

  test -z "$valid_tags" &&
  log "Looking for unmatched paths in $d" ||
  log "Validating $d, using valid patterns $valid_tags"

  {
    eval find $d "$find_ignores -o \( -type l -o -type f \) -a -print "
    echo "\l"
  } | matchbox.py check-names $valid_tags
}

c_fix_names()
{
  local path_regex names_tables names_table
  req_path_arg "$1"
  match_grep_pattern_test "$path" || return 1
  path_regex="$p_"
  match_name_tables "$path"
  # 
  htd_find_path_locals table.names $(pwd)
  names_tables=$path_locals
  for names_table in $names_tables
  do
    cat $names_table | grep -Ev '^(#.*|\s*)$' | while read match pattern tag
    do
      echo "$match" | grep '^'$path_regex > /dev/null || continue
      match_name_pattern "$pattern"
      for p in $match
      do
        echo "$p" | grep '^'"$grep_pattern"'$' >> /dev/null && {
          test -n "$tag" && {
            echo matched $tag $p
          } || {
            echo ok $p
          }
        } || test -n "$tag" || {
          echo mismatch $p
        }
      done
    done
  done
}

htd_host_arg()
{
  test -z "$1" && host=$1 || host=${hostname}
}

# TODO: pre-process file/metadata
c_resolve()
{
  set --
}

# GIT commits and push
c_pci()
{
  git add -u;git commit -m "$1";git push --all
}

# Move path to archive path in htdocs cabinet
# $ archive [<prefix>]/[<datepath>]/[<id>] <refs>...
c_archive()
{
  test -n "$1" || error "ID expected"
}

## Annex:

# Save refs (download locators if not present) to prefix,
# building a full path for each ref from the prefix+ids+filetags.
# $ save "[<prefix>/]<id>" <refs>...
# TODO: define global <prefix> and <id> to correspond with (sets of) path instances
# ie. lookup given prefix and id first, see if it exists.
# XXX: may have lookup lookup. Use -g to override.
# <prefix> 
c_save()
{
  c_save_tags "$1"
  c_save_url "$@"
}

c_save_tags()
{
  set -- $@
  while test -n "$1"
  do
    tags.py get "$1" || tags.py insert "$1"
    shift 1
  done
}

c_tags()
{
  test -n "$1" || set -- "*"
  tags.py find "$1"
}

c_save_topics()
{
  test -n "$1" || error "Document expected" 1
  test -e "$1" || error "No such document $1" 1
  c_tpaths "$1" | while read path
  do
    echo
  done
}


c_save_url()
{
  annex=/Volumes/Simza/Downloads
  test "$(pwd -P)" = $annex || cd $annex

  test -n "$1" || error 'URL expected' 1
  test -n "$2" || {
    parseuri.py "$1"
    error "TODO: get filename"
  }
  test ! -e "$2" || error "File already exists: $2" 1
  git annex addurl "$1" --file "$2"
}

c_save_ref()
{
  test -n "$1" || error "tags expected" 1
  tags="$1"
  
  shift 1
  for ref in "$@"
  do
    echo $ref
  done
}

c_commit()
{
  echo -e
}

c_show_rules()
{
  htd_host_arg $@
  cat ~/.conf/rules/$host/$project.sh
}

c_run_rules()
{
  set --
}

c_add_rule()
{
  set --
}

# parse path and annex metadata using given path

req_arg_pattern="Pattern format"
req_arg_path="Path"

c_name_tags_test()
{
  match_name_vars $@
}

c_name_tags()
{
  local pattern
  req_arg "$1" 'name-tags' 1 pattern && shift 1|| return 1
  req_arg "$1" 'name-tags' 2 path && path="$1" || return 1
  c=0
  test "${path: -1:1}" = "/" && path="${path:0: -1}"
  test -d "$path" && {
    eval find "$path $find_ignores -o \( -type f -o -type l \) -a -print" \
    | while read p
    do
      echo $p
      match_name_vars "$pattern" "$p" 2> /dev/null
      #c=$(( $c + 1 ))
      #echo $c
      #echo
    done
  } || {
    error "Req dir arg" 1
  }
}

c_name_tags_all()
{
  req_arg "$1" 'name-tags-all' 1 path && path="$1" || return 1
  test "${path: -1:1}" = "/" && path="${path:0: -1}"
  test -d "$path" && {
    eval find "$path $find_ignores -o \( -type f -o -type l \) -a -print" \
    | while read p
    do
      match_names "$p"
    done
  } || {
    error "Req dir arg" 1
  }
}

c_update()
{
  for CK in ck sha1 md5
  do
    c_ck_prune $CK
    c_ck_clean $CK
    c_ck_update $CK
  done
}


# Checksums

ck_arg_spec="[ck|sha1|md5]"
ck_arg()
{
  test -n "$1"  && CK=$1  || CK=ck
  test -e table.$CK || {
    error "First argument must be CK table extension, no such table: table.$CK" 1
  }
  test -r table.$CK || {
    error "Not readable: table.$CK" 1
  }
  T_CK="$(echo $CK | tr 'a-z' 'A-Z')"
}

ck_write()
{
  ck_arg "$1"
  test -w table.$CK || {
    error "Not writable: table.$CK" 1
  }
}

c_man_5_table_ck="Table of CK checksum, filesize and path"
c_man_5_table_sha1="Table of SHA1 checksum and path"
c_man_5_table_md5="Table of MD5 checksum and path"
# Either check table for path, or iterate all entries. Echoes checksum, two spaces and a path
c_ck_table()
{
  # table ext
  ck_arg "$1"
  shift 1
  # second table ext
  test -n "$1" -a -e "table.$CK.$1" && {
    S=$1; shift 1
  } || S=
  test -z "$1" && {
    # run all entries
    cat table.$CK$S | grep -Ev '^\s*(#.*|\s*)$' | \
    while read -a ckline
    do
      test "$CK" = "ck" && {
        cks=${ckline[@]::1}
        sz=${ckline[@]::1}
        p="${ckline[@]:2}"
      } || {
        cks=${ckline[@]::1}
        p="${ckline[@]:1}"
      }
      echo "$cks  $p"
    done
  } || {
    # look for single path
    htd_relative_path "$1"
    match_grep_pattern_test "$relpath" || return 1
    grep ".*\ \(\.\/\)\?$p_$" table.$CK$S >> /dev/null && {
      grep ".*\ \(\.\/\)\?$p_$" table.$CK$S | cut -f 1 -d ' '
    } || {
      echo unknown
      return 1
    }
  }
}

c_man_1_ck_table_subtree="Like ck-table, but this takes a partial path starting at the root level and returns the checksum records for files below that. "
c_spc_ck_table_subtree="ck-tabke-subtree $ck_arg_spec <path>"
c_ck_table_subtree()
{
  ck_arg "$1"
  shift 1
  test -n "$1" || return 1
  match_grep_pattern_test "$1" || return 1
  grep ".*\ $p_.*$" table.$CK | grep -v '^#|\s*$' | while read -a ckline
    do
      test "$CK" = "ck" && {
        cks=${ckline[@]::1}
        sz=${ckline[@]::1}
        p="${ckline[@]:2}"
      } || {
        cks=${ckline[@]::1}
        p="${ckline[@]:1}"
      }
      echo "$cks  $p"
    done
}

ck_update_file()
{
  ck_write "$CK"
  update_file="$1"
  # FIXME use test name again but must have some testcases
  # to verify because currently htd_name_precaution is a bit too strict
  # c_test_name
  match_grep_pattern_test "$update_file" > /dev/null || {
    error "Skip path with unhandled characters"
    return
  }
  test -r "$update_file" || {
    error "Skip path not readable by user"
    return
  }
  test -d "$update_file" && {
    error "Skipped directory path"
    return
  }
  test -L "$update_file" && {
    BE="$(dirname "$update_file")/$(readlink "$update_file")"
    test -e "$BE" || {
      error "Skip dead symlink"
      return
    }
    SZ="$(filesize "$BE")"
  } || {
    SZ="$(filesize "$update_file")"
  }
  test "$SZ" -ge "$MIN_SIZE" || {
    error "File too small: $SZ"
    return
  }
  # test localname for SHA1 tag
  BN="$(basename "$update_file")"
  # XXX hardcoded to 40-char hexsums ie. sha1
  HAS_CKS="$(echo "$BN" | grep '\b[0-9a-f]\{40\}\b')"
  cks="$(echo "$BN" | grep '\b[0-9a-f]\{40\}\b' |
    sed 's/^.*\([0-9a-f]\{40\}\).*$/\1/g')"
  # FIXME: normalize relpath
  test "${update_file:0:2}" = "./" && update_file="${update_file:2}"
  #EXT="$(echo $BE)"
  test -n "$HAS_CKS" && {
    c_ck_table "$CK" "$update_file" > /dev/null && {
      echo "path found"
    } || {
      grep "$cks" table.$CK > /dev/null && {
        echo "$CK duplicate found or cannot grep path"
        return
      }
      CKS=$(${CK}sum "$update_file" | cut -d' ' -f1)
      test "$cks" = "$CKS" || {
        error "${CK}sum $CKS does not match name $cks from $update_file"
        return
      }
      echo "$cks  $update_file" >> table.$CK
      echo "$cks added"
      return
    }
    return
  } || {
    # TODO prepare to rename, keep SHA1 hashtable
    c_ck_table "$CK" "$update_file" > /dev/null && {
      echo ok
    } || {
      ${CK}sum "$update_file" >> table.$CK
      echo new
    }
  }
}

ck_update_find()
{
  log "Reading $T_CK, looking for paths '$1'"
  find_p="$1"
  # strip trailing slash
  test "${find_p: -1:1}" = "/" && find_p="${find_p:0: -1}"
  eval find "$find_p" $find_ignores -o -print \
  | while read p
    do
      ck_update_file "$p"
    done
}

# find all files, check their names, size and checksum
c_ck_update()
{
  ck_write "$1"
  shift 1
  #args=($@);
  while test -e "$1"
  do
    update_p="$1"
    shift 1
    log "Checking '$update_p'"
    test -z "$update_p"  && {
      ck_update_find . 
      continue
    }
    test -d "$update_p"  && {
      ck_update_find "$update_p"
      continue
    }
    test -f "$1" && {
      ck_update_file "$1"
      continue
        }
    test -L "$1"  &&  {
      ck_update_file "$1" || return 4
      continue
    }
    shift 1
  done
  test -z "$1" || error "Unknown path '$1'" 1
}

c_ck_drop()
{
  ck_write "$1"
  shift 1
  ck_drop "$1"
  req_arg "$1" 'ck-drop' 2 path || return 1
  match_grep_pattern_test "$1" || return 1
  cp table.$CK table.$CK.tmp
  cat table.$CK.tmp | grep "^.*$p_$" >> table.$CK.missing
  cat table.$CK.tmp | grep -v "^.*$p_$" > table.$CK
  rm table.$CK.tmp
}

c_man_1_ck_clean="Iterate checksum table, check for duplicates, normalize paths"
c_spc_ck_clean="clean $ck_arg_spec"
c_ck_clean()
{
  ck_arg "$1"
  shift 1
  test "$CK" = "ck" && {
    set --
  } || {
    set --
  }
}

c_spc_ck_validate="ck-validate $ck_arg_spec"
c_ck_validate()
{
  ck_arg "$1"
  shift 1
  test "$CK" = "ck" && {
    c_checksums table.$CK
  } || {
    ${CK}sum -c table.$CK
  }
}

# check file size and cksum
c_spc_checksums="checksums [<table-file>]"
c_checksums()
{
  test -n "$1"  && T=$1  || T=table.ck
  cat $T | while read cks sz p
  do
    SZ="$(filesize "$p")"
    test "$SZ" = "$sz" || { error "File-size mismatch on '$p'"; continue; }
    CKS="$(cksum "$p" | awk '{print $1}')"
    test "$CKS" = "$cks" || { error "Checksum mismatch on '$p'"; continue; }
    echo "$cks ok"
  done
}

# Drop non-existant paths from table, copy to .missing
c_ck_prune()
{
  ck_write "$1"
  shift 1
  log "Pruning missing files from $CK table"
  c_ck_table $CK | while read cks p
  do
    test -e "$p" || {
      c_ck_drop $CK "$p"
      echo "Dropped $CK key $cks for '$p'"
    }
  done
}

# Read checksums from *.{sha1,md5,ck}{,sum}
c_ck_consolidate()
{
  eval "find . $find_ignores -o -name '*.{sha1,md5,ck}{,sum}' -a \( -type f -o -type l \) " -print | while read p
  do
    echo "$p"
  done
}

# try to find files from .missing, or put them in .gone
c_ck_clean()
{
  ck_write "$1"
  shift 1
  test -s "table.$CK.missing" || {
    error "$T_CK.missing table does not exists"
    return
  }
  log "Looking for missing files from $CK table"/
  c_ck_table $CK .missing | while read cks p
  do
    BN="$(basename "$p")"
    NW=$(eval find ./ $find_ignores -o -iname '$BN' -print)
    test -n "$NW" && echo "$BN -> $NW"
  done
  echo 'TODO rewrite ck table path'
}

# TODO consolidate meta
c_ck_metafile()
{
  [ -n "$1" ] && d=$1 || d=.
  CK=sha1
  eval find $d $find_ignores -o -iname \'*.meta\' -print \
  | while read metafile
  do
    ck_mf_p="$(dirname "$metafile")/$(basename "$metafile" .meta)"
    [ -e "$ck_mf_p" ] || {
      echo "missing source file $metafile: $ck_mf_p"
      continue
    }
    cks=$(rsr.py --show-sha1sum-hexdigest "$ck_mf_p" 2> /dev/null)
    c_ck_table "$CK" "$ck_mf_p" > /dev/null && {
      log "$cks found"
    } || {
      CKS=$(${CK}sum "$ck_mf_p" | cut -d' ' -f1)
      #echo CKS=$CKS cks=$cks
      test "$cks" = "$CKS" && {
        log "$CKS ok $ck_mf_p"
      } || {
        error "Corrupt file: $ck_mf_p"
        continue
      }
      echo "$CKS  $ck_mf_p" >> table.$CK
    }
    
  done
}

# validate torrent
c_ck_torrent()
{
  test -s "$1" || error "Not existent torrent arg 1: $1" 1
  test -f "$1" || error "Not a torrent file arg 1: $1" 1
  test -z "$2" -o -d "$2" || error "Missing dir arg" 1
  htwd=$(pwd)
  dir=$2
  test "$dir" != "." && pushd $2 > /dev/null
  test "${dir: -1:1}" = "/" && dir="${dir:0: -1}"
  log "In $dir, verify $1"

  #echo testing btshowmetainfo
  #btshowmetainfo $1

  node $PREFIX/bin/btinfo.js "$1" > /tmp/htd-ck-torrent.sh
  . /tmp/htd-ck-torrent.sh
  echo BTIH:$infoHash

  torrent-verify.py "$1" | while read line
  do
    test -e "${line}" && {
      echo $htwd/$dir/${line} ok
    }
  done
  test "$dir" != "." && popd > /dev/null
}


# xxx find corrupt files: .mp3
c_mp3_validate()
{
  eval "find . $find_ignores -o -name "*.mp3" -a \( -type f -o -type l \) -print" \
  | while read p
  do
    SZ=$(filesize "$p")
    test -s "$p" || {
      error "Empty file $p"
      continue
    }
    mp3val "$p"
  done
}


c_tmux_prive()
{
  cd
  tmux has-session -t Prive >/dev/null || {
    c_tmux_init Prive
    tmux send-keys -t Prive:1 "reset;cd;git st" enter
  }
  tmux list-windows -t Prive | grep -q HtD || {
    tmux new-window -t Prive -n HtD
    tmux send-keys -t Prive:HtD "reset;cd ~/htdocs/; htd today personal/journal;git st" enter
    tmux send-keys -t Prive:HtD "git add -u;git add dev/ personal/*.rst personal/journal/2*.rst sysadmin/*.rst *.rst;git st" enter
  }
  tmux list-windows -t Prive | grep -q '\ conf' || {
    tmux new-window -t Prive -n conf
    tmux send-keys -t Prive:conf "reset;cd ~/.conf;git st" enter
  }
  tmux list-windows -t Prive | grep -q Bin || {
    tmux new-window -t Prive -n Bin
    tmux send-keys -t Prive:Bin "reset;cd ~/bin;git st" enter
  }
  tmux list-windows -t Prive | grep -q Ino || {
    tmux new-window -t Prive -n Ino
    tmux send-keys -t Prive:Ino "reset;cd ~/project/arduino-docs;git st" enter
  }
  tmux list-windows -t Prive | grep -q Avr || {
    tmux new-window -t Prive -n Avr
    tmux send-keys -t Prive:Avr "reset;cd ~/project/arduino-docs;git st" enter
  }
  tmux list-windows -t Prive | grep -q Loci || {
    tmux new-window -t Prive -n Loci
    tmux send-keys -t Prive:Loci "reset;cd ~/project/node-loci;git st" enter
  }
}

c_tmux_work()
{
  cd ~/work/brix

  # Make sure Work session is registered with tmux server

  tmux has-session -t Work >/dev/null || {
    c_tmux_init Work bash
  }

  # Make sure Log window is on and first window (swapping some windows if
  # needed, maybe better way it to start server by hand instead of usign new-session?)

  tmux list-windows -t Work | grep -q Log || {
    # No log, new session, need to clean up first window, add one first to keep session
    tmux new-window -t Work -n temporary
    tmux kill-window -t Work:1
  }

  tmux list-windows -t Work | grep -q '1:\ Log' || {
    tmux new-window -t Work -n Log
    tmux send-keys -t Work:Log "reset;cd ~/work/brix/;htd today log" enter
    tmux send-keys -t Work:Log "(cd log;git add -u;git add 20*.rst; git st)" enter
  }

  tmux list-windows -t Work | grep -q temporary && {
    tmux kill-window -t Work:temporary
  } || noop

  # Add other windows

  tmux list-windows -t Work | grep -q Tree || {
    tmux new-window -t Work -n Tree
    tmux send-keys -t Work:Ba "reset;cd ~/work/brix/tree/" enter "make status" enter
  }
  tmux list-windows -t Work | grep -q Cleaning || {
    tmux new-window -t Work -n Tree
    tmux send-keys -t Work:Ba "reset;cd /Volumes/Simza/WorkCleaning/brix" enter "make status" enter
  }

  #tmux list-windows -t Work | grep -q Jnk || {
  #  tmux new-window -t Work -n Jnk
  #  tmux send-keys -t Work:Jnk "reset;cd ~/work/brix/Jenkins;ls -la" enter
  #}

  #tmux list-windows -t Work | grep -q DvD || {
  #  tmux new-window -t Work -n DvD
  #  tmux send-keys -t Work:DvD "reset;cd ~/work/brix/tree/dev-doc;git fetch --all;git st" enter
  #}
  tmux list-windows -t Work | grep -q Mng || {
    tmux new-window -t Work -n Mng
    tmux send-keys -t Work:Mng "reset;cd /Volumes/Simza/WorkCleaning/brix/tree/mango-builds" enter "git st" enter
  }
  tmux list-windows -t Work | grep -q BrxStd || {
    tmux new-window -t Work -n BrxStd
    tmux send-keys -t Work:BrxStd "reset;cd /Volumes/Simza/WorkCleaning/brix/tree/brixcloud-studio-testing" enter "git st" enter
  }
  #tmux list-windows -t Work | grep -q Skl || {
  #  tmux new-window -t Work -n Skl
  #  tmux send-keys -t Work:Skl "reset;cd ~/work/brix/tree/project-skeleton-ng" enter "git st" enter
  #}
}

c_tmux_srv()
{
  cd /srv
  tmux has-session -t Srv >/dev/null || {
    c_tmux_init Srv
    tmux send-keys -t Srv:bash "reset; cd ~/.conf; ./script/update.sh" enter
  }
  tmux list-windows -t Srv | grep -q HtD-Sf || {
    tmux new-window -t Srv -n HtD-Sf
    tmux send-keys -t Srv:HtD-Sf "reset; cd ~/htdocs/; sitefile" enter
  }
  tmux list-windows -t Srv | grep -q BrX-Sf || {
    tmux new-window -t Srv -n BrX-Sf
    tmux send-keys -t Srv:BrX-Sf "reset; cd ~/work/brix/; sitefile" enter
  }
  tmux list-windows -t Srv | grep -q X-Tw || {
    tmux new-window -t Srv -n X-Tw
    tmux send-keys -t Srv:X-Tw "reset; cd ~/project/x-tiddlywiki; tiddlywiki x-tiddlywiki --server" enter
  }
  tmux list-windows -t Srv | grep -q Loci || {
    tmux new-window -t Srv -n Loci
    tmux send-keys -t Srv:Loci "reset; cd ~/project/node-loci; npm start" enter
  }
}


c_tmux_init()
{
  test -n "$1" || error "session name required" 1
  test -n "$2" || set -- "$1" "bash"
  #'reattach-to-user-namespace -l /bin/bash'"
  test -z "$3" || error "surplus arguments: '$3'" 1

  socket=/tmp/tmux-htd-socket
  out=/tmp/htd-tmux-init-$$

  test -n "$TMUX_TMPDIR" || TMUX_TMPDIR=/opt/tmux-socket

  tmux has-session -t $1 >/dev/null && {
    logger "Session $1 exists" 0
    note "Session $1 exists" 0
  } || {

    tmux new-session -P -s "$1" -d "$2" 2>&1 1> $out

    tmux has-session -t $1 >/dev/null && {
      note "started new session '$1'"
      logger "started new session '$1'"
    } || {
      logger "Failed starting session ($?) ($out): $(echo $(cat $out))"
    }
    printf "Cat ($out) "
    cat $out
    rm $out

  }
}

c_reader_update()
{
  cd /Volumes/READER

  for remote in .git/refs/remotes/*
  do
    name="$(basename "$remote")"
    younger_than "$remote" _1HOUR && {
      info "Remote $name is up-to-date"
    } || {
      note "Remote $name is too old, syncing"
      git annex sync $name && continue || error "sync failed"
    }
  done

  note "Removing dead symlinks (annex content elsewhere), for PRS software"
  find ./ -type l | while read l
  do
      test -e "$l" || rm "$l"
  done
}

c_man_1_test="no test, just checking it goes"
c_test()
{
  ./test/*-spec.bats
}
c_als__t=test


c_man_1_edit_test="edit-tests"
c_edit_test()
{
  $EDITOR ./test/*-spec.bats
}
c_als__T=edit-test


c_man_1_inventory="All inventories"
c_inventory()
{
  $EDITOR personal/inventory/{main,*}.rst
  git add personal/inventory/{main,*}.rst
}

c_man_1_inv_elec="Electrics inventory"
c_inv_elec()
{
  $EDITOR personal/inventory/{components,modules,hardware}.rst
  git add personal/inventory/{components,modules,hardware}.rst
}

c_disk_id()
{
  test -n "$1" || error "Disk expected" 1
  test -e "$1" || error "Disk path expected '$1'" 1

  diskid="$(sudo fdisk -l $1 | grep Disk.identifier\
      | sed 's/^Disk.identifier: //')"
  echo $diskid
}

c_disk_model()
{
  test -n "$1" || error "Disk expected" 1
  test -e "$1" || error "Disk path expected '$1'" 1

  diskmodel="$(sudo parted -s $1 print | grep Model: \
      | sed 's/^Model: //')"
  echo $diskmodel
}

c_disk_size()
{
  test -n "$1" || error "Disk expected" 1
  test -e "$1" || error "Disk path expected '$1'" 1

  disksize="$(sudo parted -s $1 print | grep Disk.*: \
      | sed 's/^Disk[^:]*: //')"
  echo $disksize
}

c_disk_tabletype()
{
  test -n "$1" || error "Disk expected" 1
  test -e "$1" || error "Disk path expected '$1'" 1

  disktabletype="$(sudo parted -s $1 print | grep Partition.Table: \
      | sed 's/^Partition.Table: //')"
  echo $disktabletype
}

find_partition_ids()
{
  find /dev/disk/by-uuid -type l | while read path
  do
    test "$(basename $(readlink $path))" != "$(basename $1)" || {
      echo UUID:$(basename $path)
    }
  done

  if test -e /dev/disk/by-partuuid
  then
    find /dev/disk/by-partuuid -type l | while read path
    do
      test "$(basename $(readlink $path))" != "$(basename $1)" || {
        echo PART-UUID:$(basename $path)
      }
    done
  fi
}

c_disks()
{
  DISKS=/dev/sd[a-e]
  for disk in $DISKS
  do
    echo "$disk $(htd disk-id $disk)"
    echo "  :table-type: $(htd disk-tabletype $disk)"
    echo "  :size: $(htd disk-size $disk)"
    echo "  :model: $(htd disk-model $disk)"
    echo ""
    for dp in $disk[0-9]*
    do
        pn="$(echo $dp | sed 's/^.*\([0-9]*\)/\1/')"
        ps="$(parted $disk -s print | grep '^\ '$pn | awk '{print $4}')"
        pt="$(parted $disk -s print | grep '^\ '$pn | awk '{print $5}')"
        fs="$(parted $disk -s print | grep '^\ '$pn | awk '{print $6}')"
        echo "  - $dp $pt $(echo $(find_partition_ids $dp)) $ps $fs"
    done
    echo
  done
  echo
}


c_realpath()
{
  realpath "$@"
}

c_normalize_symbolic()
{
  normalize_symbolic "$@"
}

c_normalize_relative()
{
  normalize_relative "$@"
}

# Get document part using xpath
# XXX: relies on rST/XML.
c_getx()
{
  test -n "$1" || error "Document expected" 1
  test -e "$1" || error "No such document <$1>" 1
  test -n "$2" || error "XPath expr expected" 1

  test -n "$3" || set "$1" "$2" "$(c_getxl $1)"

  xmllint --xpath "$2" "$3"
}

# Get x-lang file for arg1
c_getxl()
{
  fnmatch '*.xml' $1 && set -- "$1" "$1"
  fnmatch '*.rst' $1 && {
    test -n "$2" || set -- "$1" "/tmp/$(basename $1 .rst).xml"
    $rst2xml $1 > "$2"
    echo $2
  }
  test -e "$2" || error "Need XML repr of doc $1" 1
}

# List topic paths (nested dl terms) in document paths, unique results only
c_tpaths()
{
  test -n "$1" || error "At least one document expected" 1
  test -n "$print_src" || local print_src=

  {
    while test -n "$1"
    do
      test -e "$1" || {
        warn "No file <$1>, skipped"
        shift 1
        continue
      }
      local path= rel_leaf= root=
      # Read multi-leaf paths, and split it up into relative leafs
      c_xproc "$(c_getxl $1)" $scriptdir/rst-terms2path.xsl \
        | grep -Ev '^(#.*|\s*)$' \
        | sed 's/\([^\.]\)\/\.\./\1\
../g' \
        | grep -v '^\.[\.\/]*$' \
        | while read rel_leaf
      do

        # Assemble each leaf path onto its root, and normalize
        echo "$rel_leaf" | grep -q '^\.\.\/' && {
          path="$(normalize_relative "$root/$rel_leaf/")"
        } || {
          path="$(normalize_relative "$rel_leaf/")"
          root=$rel_leaf
        }

        #test -n "$path" \
        #  || continue
        test -n "$print_src" \
          && echo "$1 $path" \
          || echo "$path"

      done
      shift 1
    done
  } | grep -Ev '^(#.*|\s*)$' | sort -u
}

c_tpath_raw()
{
  test -n "$1" || error "document expected" 1
  test -e "$1" || error "no such document '$1'" 1
  c_xproc "$(c_getxl "$1")" $scriptdir/rst-terms2path.xsl
}

# Process XML using XSLT
c_xproc()
{
  {
    fnmatch '<* *>' "$2" && {

      xsltproc - $1 <<EOM
$2
EOM
    } || {
      xsltproc $2 $1
    }
  # remove XML prolog:
  } | tail -n +2 | grep -Ev '^(#.*|\s*)$'
}

# TODO: Append definition term to doc
c_dl_init()
{
  test -n "$1" || error "Document expected" 1
  test -e "$1" || error "Document expected: <$1>" 1
  test -n "$2" || error "Term expected" 1
  htd getx '//*/term[text()="'$2'"]' "$1"
}

# TODO: Add list item beneath definition term
c_dl_append()
{
  echo
}

# XXX: hacky hacking one day, see wishlist above
list_host_disks()
{
  htd getx sysadmin/$hostname.rst \
    "//*/term[text()='Disk']/ancestor::definition_list_item/definition/definition_list" \
    > /tmp/$hostname-disks.xml
  {
    xsltproc - /tmp/$hostname-disks.xml <<EOM
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="definition_list_item">
<xsl:value-of select="term"/> .
</xsl:template>
</xsl:stylesheet>
EOM
  # remove XML prolog:
  } | tail -n +2 | grep -Ev '^(#.*|\s*)$'
}

c_check_disks()
{
  test -d $HTDIR || error "No HTDIR" 1
  cd $HTDIR
  list_host_disks | while read label path id eol
  do
    test -e "$path" && {
      echo "Path for $label OK"
      xmllint --xpath \
          "//definition_list/definition_list_item/definition/bullet_list/list_item[contains(paragraph,'"$path"')]/ancestor::bullet_list" \
          /tmp/$hostname-disks.xml > /tmp/$hostname-disk.xml;
      {
    xsltproc - /tmp/$hostname-disk.xml <<EOM
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="//bullet_list/list_item">
<xsl:value-of select="paragraph/text()"/> .
</xsl:template>
</xsl:stylesheet>
EOM
  # remove XML prolog:
  } | tail -n +2 | grep -Ev '^(#.*|\s*)$' \
      && {
        echo
      } || {
        warn "failed $?"
      }

    } || {
      error "Missing $label $id <$path>" 1
    }
  done
}


# Setup X tcp socket for VS1 containers
c_xtcp()
{
  socat TCP-LISTEN:6000,reuseaddr,fork UNIX-CLIENT:\"$DISPLAY\"
}


gcal_tab=~/.conf/google/cals.tab

gcal_tab_ids()
{
  if test -n "$1"
  then
    cat $gcal_tab
  else
    grep '\<'$1 $gcal_tab
  fi
}

# List current and upcoming events
c_events()
{
  test -n "$2" || set -- "$1" "days=3"

  cat ~/.conf/google/cals.tab | while read calId summary
  do
    note "Upcoming events for '$summary'"
    gcal.py list-upcoming 7 $calId "$2" 2>/dev/null
  done
}

# List upcoming events at any date
c_upcoming_events()
{
  gcal_tab_ids "$1" | while read calId summary
  do
    note "Upcoming events for '$summary'"
    gcal.py list-upcoming 7 $calId 2>/dev/null
  done
}

# List events of +/- 1day
c_current_events()
{
  test -n "$2" || set -- "$1" "days=1" "$3" "$4"
  test -n "$3" || set -- "$1" "$2" "days=1" "$4"
  test -n "$4" || set -- "$1" "$2" "$3" "7"

  gcal_tab_ids "$1" | while read calId summary
    do
      note "Current events ($2/$3) for '$summary' ($calId)"
      gcal.py happening-now $7 $calId "$1" "$2" 2>/dev/null
    done
}



### Main


htd__main()
{
  htd_init || return 0

  local scriptname=htd base=$(basename $0 .sh) verbosity=5

  case "$base" in $scriptname )

      local subcmd_def= \
        subcmd_pref= subcmd_suf= \
        subcmd_func_pref=c_ subcmd_func_suf=

      htd_lib

      # Execute
      main "$@"
      ;;

    #* )
    #  error "not a frontend for $base"
    #  ;;
  esac
}

htd_init()
{
  test -n "$PREFIX" || PREFIX=$HOME
  test -z "$BOX_INIT" || return 1
  . $PREFIX/bin/box.init.sh
  . $PREFIX/bin/util.sh
  box_run_sh_test
  . $PREFIX/bin/main.sh
  . $PREFIX/bin/main.init.sh
  . $PREFIX/bin/box.lib.sh
  . $PREFIX/bin/date.lib.sh
  # -- htd box init sentinel --
}

htd_lib()
{
  . $PREFIX/bin/match.sh "$@"
  # -- htd box lib sentinel --
  set --
}

# Use hyphen to ignore source exec in login shell
if [ -n "$0" ] && [ $0 != "-bash" ]; then

  scriptdir=$(htd realpath $(dirname $0))
  htd__main "$@"
fi
