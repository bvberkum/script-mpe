#!/usr/bin/env bash

set -e

scriptname=htd
VERBOSITY=0

load()
{
	[ -n "$EDITOR" ] || EDITOR=vim
	[ -n "$HTD_GIT_REMOTE" ] || HTD_GIT_REMOTE=default
	[ -n "$HTDIR" ] || HTDIR=~/htd
	[ -n "$PROJECT" ] || PROJECT="$(basename $(pwd))"
	_14MB=14680064
	_6MB=7397376
	[ -n "$MIN_SIZE" ] || MIN_SIZE=$_6MB

	test -e table.sha1 && R_C_SHA3="$(cat table.sha1|wc -l)"

	rows=$(stty size|awk '{print $1}')
	cols=$(stty size|awk '{print $2}')

	find_ignores="-not -path \"*.git*\" "$(echo $(cat .gitignore | \
		grep -Ev '^(#.*|\s*)$' | \
		sed -E 's/^\//\.\//' | \
		sed -E 's/(.*)/ -not -path "\1"/g'))
}

c_usage()
{
	echo "$scriptname.sh Bash/Shell script helper"
	echo 'Usage: '
	echo "  $scriptname <cmd> [<args>..]"
}

c_help()
{
	c_usage
	echo 'Commands: '
	echo '  home                             Print htd dir.'
	echo '  info                             Print vars.'
	echo '  mk|make                          Run make (in htd dir).'
	echo '  st|stat                          Run make stat.'
	echo '  sys                              Run make sys.'
	echo '  vt|vtoday                        Run make vtoday.'
	echo ''
	echo '  wol <host>                       Send wol.'
	echo '  mac                              List ARP table: hwaddr for clients (once) connector to LAN. '
	echo '  todo'
	echo '  git-remote [repo]                List all names remotely, or give the SSH url for given repo. '
	echo '  git-init-remote [repo]           Initialze remote bare repo if local path is GIT project'
	echo '  git-remote-info                  Show vars'
	echo ''
	echo '  test-name <path>                 Test filename for unhandled characters. '
	echo '  update-ck-table [ck|md5|sha1]    Checkums all files. '
	echo "  ck-table [ck|md5|sha1] <path>    Check if checksum exists for file, don\'t validate or update. "
	echo '  ck-validate [ck|md5|sha1]        Verify each file by generating and comparing its checksum'
	echo ''
	echo 'Other commands: '
	echo '  -e                               Edit this script.'
	echo '  alias                            Show bash aliases for this script.'
	echo '  usage                            print just the usage description.'
	echo '  help                             print this help listing.'
}

c_home()
{
	echo $HTDIR
}

c_info()
{
	log "HtDir: $HTDIR"
	log "Script: $(pwd)/$scriptname"
	log "Project ID: $PROJECT"
	log "Minimum filesize: $(( $MIN_SIZE / 1024 ))"
	log "Editor: $EDITOR"
	log "Default GIT remote: $HTD_GIT_REMOTE"
}

c_expand()
{
	test -n "$1" || return 1
	for x in $1
	do
		test -e "$x" && echo $x
	done
}

c_edit()
{
	[ -n "$1" ] && fn=$1 || fn=$(which htd)
	$EDITOR $fn
}
c__e()
{
	c_edit
}

c_fsck()
{
	c_ck_validate sha1
}

c_make()
{
	cd $HTDIR && make $*
}
c_mk()
{
	c_make $*
}

# Run a sys-* target in the htdocs dir.
c_make_sys()
{
	cd $HTDIR
	for x in $*
	do
		make system-$x
	done
}

c_stat()
{
	c_make stat
}
c_st()
{
	c_stat $*
}

# experiment rewriting console output
clear_lines()
{
	count=$1
	[ -n "$count" ] || count=0

	while [ "$count" -gt -1 ]
	do
		# move forward to end, then erase one line
		echo -ne "\033[200C"
		echo -ne "\033[1K"
		# move up 
		echo -ne "\033[1A"
		count=$(( $count - 1 ))
	done

	# somehow col is one off, ie. the next regular echo has the first character
	# eaten by the previous line. clean one line here
	echo
}
capture_and_clear()
{
	tee /tmp/htd-out
	mv /tmp/htd-out /tmp/htd-out.tmp
	fold -s -w $cols /tmp/htd-out.tmp > /tmp/htd-out
	lines=$(wc -l /tmp/htd-out|awk '{print $1}')
	clear_lines $lines
	echo Captured $lines lines
}
c_build()
{
	rm -f /tmp/htd-out
	c_make build 2>1 | capture_and_clear
	echo Mixed output::
	echo
	cat /tmp/htd-out | sed  's/^/    /'
}

# show htd shell aliases
c_alias()
{
	grep '\<htd\>' ~/.alias | grep -v '^#' | while read _a A
	do
		a_id=$(echo $A | awk -F '=' '{print $1}')
		a_shell=$(echo $A | awk -F '=' '{print $2}')
		echo -e "   $a_id     \t$a_shell"
	done
}

# Open an editor to edit todays log
c_vtoday()
{
	c_make vtoday
}
c_vt()
{
	c_vtoday $*
}

# Wake a remote host using its ethernet address
wol_hwaddr=~/.conf/wol/hosts-hwaddr.sh
c_wol_list_hosts()
{
	cat $wol_hwaddr
	err "Expected hostname argument" 2
}
c_wol()
{
	host=$1
	[ -z "$host" ] && {
		c_wol_list_hosts
	} || {
		declare $(echo $(cat $wol_hwaddr))
		hwaddr=$(eval echo \$$host)
		[ -n "$hwaddr" ] || exit 4
		wakeonlan $hwaddr
		echo ":WOL Host: \`$host <$hwaddr>\`_"
	}
}

# Simply list ARP-table, may want something better like arp-scan or an nmap
# script
c_mac()
{
	arp -a
}

# Experimenting with gtasks.. looking at todo targets
c_todo()
{
	echo
	echo "..Htdocs ToDo.."
	gtasks -L -dsc -dse -sn
	echo "Due:"
	gtasks -L -sdo -dse -sn
#	echo ""
#	gtasks -L -sb tomorrow -sa today -dse
}

# init or list SSH based remote 

source_git_remote()
{
    source ~/.conf/git-remotes/$HTD_GIT_REMOTE.sh || err "Missing HTD_GIT_REMOTE=$HTD_GIT_REMOTE script" 1
}

c_git_remote_info()
{
    source_git_remote
    echo remote.$HTD_GIT_REMOTE.dir=$remote_dir
    echo remote.$HTD_GIT_REMOTE.host=$remote_host
    echo remote.$HTD_GIT_REMOTE.user=$remote_user
}
c_git_remote()
{
    source_git_remote
    [ -z "$1" ] && {
        ssh_cmd="cd $remote_dir; ls | grep '.*.git$' | sed 's/\.git$//g' "
        ssh $remote_user@$remote_host "$ssh_cmd"
    } || {
        repo=$1
        git_url="ssh://$remote_host/~$remote_user/$remote_dir/$repo.git"
        scp_url="$remote_user@$remote_host:$remote_dir/$repo.git"
        echo $git_url
    }
}

c_git_init_remote()
{
    source_git_remote
    [ -n "$1" ] && repo="$1" || repo="$PROJECT"

    ssh_cmd="mkdir -v $remote_dir/$repo.git"
    ssh $remote_user@$remote_host "$ssh_cmd"

    [ -d .git ] || return

    c_git_remote $repo >> /dev/null

    BARE=../$repo.git
    TMP_BARE=1
    [ -d $BARE ] && TMP_BARE= || {
        [ -d /src/$repo.git ] && {
            TMP_BARE=
            BARE=/src/$repo.git
        } || {
            log "Creating temp. bare clone"
            git clone --bare . $BARE
        }
    }

    [ -n "$TMP_BARE" ] || {
        log "Using existing bare repository to init remote: $BARE"
    }

    log "Syning to $scp_url"
    rsync -azu $BARE/ $scp_url

    git remote add $HTD_GIT_REMOTE $git_url

    git fetch $HTD_GIT_REMOTE

    log "Added remote $HTD_GIT_REMOTE $scp_url"
}

# indexing, cleaning

c_test_name()
{
	echo "$@" | grep -E '^[]\[{}\(\)A-Za-z0-9\.,!@#&%*?:'\''\+\ \/_-]*$' || return 1
}

c_find_empty()
{
	eval find . -size 0 $find_ignores
}

# TODO interactive file process
c_check()
{
	log "Looking for unknown files.."
	eval find . $find_ignores \
		| while read p
		do
			c_test_name "$p" >> /dev/null || {
				err "Unhandled characters: $p"
				continue
			}
			[ -L "$p" ] && {
				BE="$(dirname "$p")/$(readlink "$p")"
				[ -e "$BE" ] || {
					#err "Skip dead symlink"
					continue
				}
				SZ="$(stat -f '%z' "$BE")"
			} || {
				SZ="$(stat -f '%z' "$p")"
			}
			if test -d "$p" -a -n "$(c_expand $p.{zip,tar{.gz,.bz2}})"
			then
				log "Skipping unpacked dir $p"
				for ck in ck sha1 md5
				do
					c_ck_table_subtree $ck "$p" | while read p2
					do
						c_ck_table $ck "" "$p2" >> /dev/null && {
							#c_ck_drop $ck "$p"
							echo "Dropped $ck key for $p"
						}
					done
				done
				continue
			fi
			test "$SZ" -ge "$MIN_SIZE" || {
				#err "File too small: $p"
				continue
			}
		done
}

c_rename()
{
	c_ck_update
}

c_update()
{
	for CK in ck sha1 md5
	do
		c_ck_prune $CK
		c_ck_clean $CK
		c_ck_update $CK
	done
}


# Checksums

c_ck_table()
{
	test -n "$1"  && CK=$1  || CK=ck
	shift 1
	test -n "$1"  && S=$1  || S=
	shift 1
	[ -z "$@" ] && {
		cat table.$CK$S | grep -v '^#|\s*$' | while read -a ckline
		do
			test "$CK" = "ck" && {
				cks=${ckline[@]::1}
				sz=${ckline[@]::1}
				p="${ckline[@]:2}"
			} || {
				cks=${ckline[@]::1}
				p="${ckline[@]:1}"
			}
			echo "$cks  $p"
		done
	} || {
		# look for single path
		p_="$(echo "$@" | sed -E 's/([^A-Za-z0-9{}(),!@_])/\\\1/g')"
		echo "$@" | grep "^$p_$" >> /dev/null || {
			err "cannot build regex for '$p': $p_"
			return
		}
		grep ".*\ $p_$" table.$CK$S >> /dev/null && {
			echo ok
		} || {
			echo unknown
			return 1
		}
	}
}

c_ck_table_subtree()
{
	test -n "$1"  && CK=$1  || CK=ck
	shift 1
	test -n "$1" || return 1
	p_="$(echo "$@" | sed -E 's/([^A-Za-z0-9{}(),!@_])/\\\1/g')"
	echo "$@" | grep "^$p_$" >> /dev/null || {
		err "cannot build regex for '$p': $p_"
		return
	}
	grep ".*\ $p_.*$" table.$CK | grep -v '^#|\s*$' | while read -a ckline
		do
			test "$CK" = "ck" && {
				cks=${ckline[@]::1}
				sz=${ckline[@]::1}
				p="${ckline[@]:2}"
			} || {
				cks=${ckline[@]::1}
				p="${ckline[@]:1}"
			}
			echo "$cks  $p"
		done
}

# find all files, check their name
c_ck_update()
{
	test -n "$1"  && CK=$1  || CK=ck
	T_CK="$(echo $CK | tr 'a-z' 'A-Z')"
	log "Reading $T_CK for objects"
	eval find . $find_ignores \
		| while read p
		do
			c_test_name "$p" >> /dev/null || {
				err "Skip path with unhandled characters"
				continue
			}
			[ -L "$p" ] && {
				BE="$(dirname "$p")/$(readlink "$p")"
				[ -e "$BE" ] || {
					#err "Skip dead symlink"
					continue
				}
				SZ="$(stat -f '%z' "$BE")"
			} || {
				SZ="$(stat -f '%z' "$p")"
			}
			test "$SZ" -ge "$MIN_SIZE" || {
				#err "File too small: $SZ"
				continue
			}
			BN="$(basename "$p")"
			HAS_CKS="$(echo $BN | grep '\.[0-9a-f]\{40\}\.')"
			CKS="$(echo $BN | grep '\.[0-9a-f]\{40\}\.' |
				sed 's/^.*\([0-9a-f]\{40\}\)\.[1-9a-z]\{3,4\}$/\1/g')"
			#EXT="$(echo $BE)"
			[ -n "$HAS_CKS" ] && {
				echo $SZ $CKS $BN $BE >> /dev/null
			} || {
				# prepare to rename, keep SHA1 hashtable
				c_ck_table "$CK" '' "$p" || {
					${CK}sum "$p" >> table.$CK
				}
			}
			continue
		done
}

c_ck_drop()
{
	test -n "$1"  && CK=$1  || CK=ck
	shift 1
	test -n "$1" || return 1
	p_="$(echo "$@" | sed -E 's/([^A-Za-z0-9{}(),!@_])/\\\1/g')"
	echo "$@" | grep "^$p_$" >> /dev/null || {
		err "cannot build regex for '$p': $p_"
		return
	}
	cp table.$CK table.$CK.tmp
	#echo "$ck  $p" >> table.$CK.missing
	cat table.$CK.tmp | grep "^.*$p_$" >> table.$CK.missing
	cat table.$CK.tmp | grep -v "^.*$p_$" > table.$CK
	rm table.$CK.tmp
}

c_ck_validate()
{
	test -n "$1"  && CK=$1  || CK=ck
	shift 1
	T_CK="$(echo $CK | tr 'a-z' 'A-Z')"
	test -s "table.$CK" || err "$T_CK table does not exists" 1
	test "$CK" = "ck" && {
		checksums table.$CK
	} || {
		${CK}sum -c table.$CK
	}
}

# check file size and cksum
checksums()
{
	test -n "$1"  && T=$1  || T=table.ck
	cat $T | while read cks sz p
	do
		SZ="$(stat -f '%z' "$p")"
		test "$SZ" = "$sz" || { err "File-size mismatch on '$p'"; continue; }
		CKS="$(cksum "$p" | awk '{print $1}')"
		test "$CKS" = "$cks" || { err "Checksum mismatch on '$p'"; continue; }
		echo "$cks ok"
	done
}

# drop non-existant paths from table, copy to .missing
c_ck_prune()
{
	test -n "$1"  && CK=$1  || CK=ck
	T_CK="$(echo $CK | tr 'a-z' 'A-Z')"
	test -s "table.$CK" || {
		err "$T_CK table does not exists"
		return
	}
	log "Pruning missing files from $CK table"
	c_ck_table $CK "" | while read cks p
	do
		test -e "$p" || {
			c_ck_drop $CK "$p"
			echo "Dropped $CK key $cks for '$p'"
		}
	done
}

# try to find files from .missing, or put them in .gone
c_ck_clean()
{
	test -n "$1"  && CK=$1  || CK=ck
	shift 1
	T_CK="$(echo $CK | tr 'a-z' 'A-Z')"
	test -s "table.$CK.missing" || {
		err "$T_CK.missing table does not exists"
		return
	}
	log "Looking for missing files from $CK table"
	c_ck_table $CK .missing | while read cks p
	do
		BN="$(basename "$p")"
		NW=$(eval find ./ -iname '$BN' $find_ignores)
		test -n "$NW" && echo "$BN -> $NW"
	done
	echo 'TODO rewrite ck table path'
}


# stdio/stderr/exit util
log()
{
	[ -n "$(echo $*)" ] || return 1;
	echo "[$scriptname.sh:$cmd] $1"
}
err()
{
	[ -n "$(echo $*)" ] || return 1;
	[ "$VERBOSITY" -ge "1" ] && echo "Error: $1 [$scriptname.sh:$cmd]" 1>&2
	echo "$1 [$scriptname.sh:$cmd]" 1>&2
	[ -n "$2" ] && exit $2
}

c_errnow()
{
	return 3
}


# Main

#def_func=c_make_stat 

if [ -n "$0" ] && [ $0 != "-bash" ]; then

	# Do something (only) if script invoked as 'htd'
	base=$(basename $0 .sh)
	case "$base" in

		$scriptname )

			# function name first as argument,
			cmd=$1
			[ -n "$def_func" -a -z "$cmd" ] \
				&& func=$def_func \
				|| func=$(echo c_$cmd | tr '-' '_')

			# load/exec if func exists
			type $func &> /dev/null && {
				func_exists=1
				load
				shift 1
				$func $@
			} || {
				# handle non-zero return or print usage for non-existant func
				e=$?
				[ -z "$cmd" ] && {
					load
					c_usage
					err 'No command given, see "help"' 1
				} || {
					[ "$e" = "1" -a -z "$func_exists" ] && {
						load
						c_usage
						err "No such command: $cmd" 1
					} || {
						err "Command $cmd returned $e" $e
					}
				}
			}

			;;

		* )
			echo No frontend for $base

	esac
fi

# vim:noet:
