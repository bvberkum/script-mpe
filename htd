#!/usr/bin/env bash

source ~/bin/match.sh
set -e

scriptname=htd
VERBOSITY=0

load()
{
	[ -n "$HTDIR" ] || HTDIR=~/htd
	[ -n "$CWDIR" ] || CWDIR=
	[ -n "$EDITOR" ] || EDITOR=vim
	[ -n "$HTD_GIT_REMOTE" ] || HTD_GIT_REMOTE=default
	# TODO look in registry for PROJECT
	[ -n "$PROJECT" ] || PROJECT="$(basename $(pwd))"
	_14MB=14680064
	_6MB=7397376
	test -n "$MIN_SIZE" || MIN_SIZE=$_6MB

	test -e table.sha1 && R_C_SHA3="$(cat table.sha1|wc -l)"

	rows=$(stty size|awk '{print $1}')
	cols=$(stty size|awk '{print $2}')

	HTD_IGNORE=.htdignore
	htd_init_ignores
	find_ignores=""$(echo $(cat $HTD_IGNORE.merged | \
		grep -Ev '^(#.*|\s*)$' | \
		sed -E 's/^\//\.\//' | \
		sed -E 's/(.*)/ -o -name "\1" -prune /g'))
	find_ignores="-path \"*/.git\" -prune $find_ignores "

	#match_load_table vars
}

htd_usage()
{
	echo "$scriptname.sh Bash/Shell script helper"
	echo 'Usage: '
	echo "  $scriptname <cmd> [<args>..]"
}

htd_commands()
{
	echo 'Commands: '
	echo '  home                             Print htd dir.'
	echo '  info                             Print vars.'
	echo '  mk|make                          Run make (in htd dir).'
	echo '  st|stat                          Run make stat.'
	echo '  sys                              Run make sys.'
	echo '  vt|vtoday                        Run make vtoday.'
	echo '  today [<prefix> [<ext>]]         Create symlinks of the format $PREFIX/{today,tomorrow,yesterday}.rst -> %Y-%m-%d.rst'
	echo ''
	echo '  vbox-start <name>                Start headless VBoxVM for VM UUID with name in VBoxVM table. '
	echo '  vbox-suspend <name>              Suspend VBoxVM. '
	echo '  vbox-reset <name>                Reboot VBoxVM. '
	echo '  vbox-stop <name>                 Stop VBoxVM. '
	echo '  vbox-list                        List known and unknown VMs. '
	echo '  vbox-running                     List running VMs. '
	echo ''
	echo '  wol <host>                       Send wol to mac for host from WOL table.'
	echo '  mac                              List ARP table: hwaddr for clients (once) connector to LAN. '
	echo '  todo'
	echo '  git-remote [repo]                List all names remotely, or give the SSH url for given repo. '
	echo '  git-init-remote [repo]           Initialze remote bare repo if local path is GIT project'
	echo '  git-remote-info                  Show vars'
	echo '  git-largest-objects (10)         List the SHA1 sums of the largest objects.'
	echo '  git-path-for-object <sha1>       Given SHA1 object, find its current path.'
	echo '  git-annex-unused                 Show keys of stored objects without path using them. '
	echo '  git-annex-show-unused            Show commit logs for unused keys. '
	echo '  git-annex-clear-unused [<to>]    Drop the unused keys, or move to remote. '
	echo ''
	echo 'Working tree utils'
	echo '  check-names [. [<tags>]]         Check names in path, according to tags.'
	echo '  list-paths [.|<dirpath]          List all paths below, including dirs. '
	echo '  test-name <path>                 Test filename for unhandled characters. '
	echo '  find-name <path|localname>       TODO: Given (partial) path, try to find the file using find.  '
	echo '  update                           Fill checksums tables for all local files. TODO: find out what there is to know about file using settings, other commands, ext. tooling & services. And trigger resolve'
	echo '  fix-names [.|<dirpath]           XXX '
	echo '  resolve                          XXX based on data and settings, pre-process and mark all files ready for commit, and bail on any irregularities. '
	echo '  commit                           XXX record metadata according to htd settings/commands. Commit is only a success, if the entire tree is either clean or ignored. '
	echo '  '
	echo 'Rules'
	echo '  show-rules [<path>]              tabulate all rules that would apply to path'
    echo '  run-rules [<path>]               (re-)run rules on path'
	echo '  add-rule <pattern> <functions>|<script> '
	echo '                                   Add either function and inline script to run for every path matching pattern. '
	echo ''
	echo 'Working tree metadata'
	echo '  ck-consolidate [.|<path>]        TODO: integrate metadata from all metafiles (see ck-metafile)'
	echo '  ck-metafile <path>               TODO: integrate metadata from .meta/.rst/.sha1sum/etc. '
	echo ''
	echo 'Working tree checksum metadata [CK_TABLE=./]'
	echo '  ck-update [ck|md5|sha1] (<path>)  Iterate all files, and create checksum table records for unknown files. '
	echo "  ck-table [ck|md5|sha1] <path>    Tell if checksum exists for file, don\'t validate or update. "
	echo '  ck-table-subtree [ck|md5|sha1] <path> '
	echo '                                   Like ck-table, but this takes a partial path starting at the root level and returns the checksum records for files below that. '
	echo '  ck-drop [ck|mk5|sha1] <path>     Remove row for given path from checksum table. '
	echo '  ck-validate [ck|md5|sha1]        Verify each file by generating and comparing its checksum. '
	echo '  ck-check [ck|md5|sha1]           Iterate table, move lines with non-existant paths to .missing table'
	echo '  ck-fix [.|<path>]                If path exists, look for duplicates using ck-find-content and move this path to .duplicates marking it to be resolved interactively. '
	echo '                                   Or if path is missing, try find-name to find new location. If still missing, look for any copy using ck-find-content and move current entry to table .duplicate on success, or .gone on failure. '
	echo '  ck-check-missing [ck|md5|sha1]   TODO: iterate .missing table, and call ck-fix. Move checksum to .gone if file stays missing. '
	echo '  ck-clean [ck|md5|sha1]           TODO: iterate .gone table, and call ck-fix. Move gone checksum if file stays missing. '
	echo '  ck-purge [|missing|duplicate|gone] TODO: drop missing-paths from indicate tables. '
	echo '  ck-dedup <path>                  With no path given, iterate the duplicate table. Otherwise deduplicate content, using given path as preferred location. '
	echo '  ck-find-content <path>           Given path, try find-name or checksum tables and annex-backend to find copies and give all alternate locations. '
	echo ''
	echo 'Other commands: '
	echo '  -e                               Edit this script.'
	echo '  alias                            Show bash aliases for this script.'
	echo '  usage                            print this comand usage listing.'
	echo '  help                             print a help description'
}

c_usage()
{
	htd_usage
	echo ''
	echo "See 'help'."

}

c_help()
{
	htd_usage
	echo ""
	htd_commands
	echo ''
	echo 'Help'
	echo "  See usage for all commands. Htd does not parse options but does use "
	echo "  environment variables. See 'info' for more env variables. "
	echo ""
	echo "env"
	echo "  CWDIR"
	echo "    If set, use instead of the current directory for working dir. "
	echo ""
}

c_home()
{
	echo $HTDIR
}

c_info()
{
	log "Script:              '$(pwd)/$scriptname'"
	log "HtDir:               '$HTDIR' [HTDIR]"
	log "Current workingdir:  '$CWDIR' [CWDIR]"
	log "Project ID:          '$PROJECT' [PROJECT]"
	log "Minimum filesize:    '$(( $MIN_SIZE / 1024 ))'"
	log "Editor:              '$EDITOR' [EDITOR]"
	log "Default GIT remote:  '$HTD_GIT_REMOTE' [HTD_GIT_REMOTE]"
	log "Ignored paths:       '$HTD_IGNORE' [HTD_IGNORE]"
}

c_expand()
{
	test -n "$1" || return 1
	for x in $1
	do
		test -e "$x" && echo $x
	done
}

c_edit()
{
	[ -n "$1" ] && fn=$1 || fn=$(which $scriptname)
	$EDITOR $fn
}
c__e()
{
	c_edit
}

htd_init_ignores()
{
	test -n "$HTD_IGNORE" || exit 1
	rm -f $HTD_IGNORE.merged
	for x in .git/info/exclude .gitignore $HTD_IGNORE
	do 
		test -s $x && {
			cat $x | grep -Ev '^(#.*|\s*)$' >> $HTD_IGNORE.merged
		}
	done
	echo $HTD_IGNORE.merged >> $HTD_IGNORE.merged
}

c_init_ignores()
{
	htd_init_ignores
}

req_path_arg()
{
	test -n "$1"  && path="$@"  || path=.
	test -d "$path" || {
		err "Must pass directory" 1
	}
}

# return paths for names that exist along given path
htd_find_path_locals()
{
    local name path stop_at
    name=$1
    path="$(cd $2;pwd)"
    test -z "$3" && stop_at= || stop_at="$(cd $3;pwd)"
    path_locals=
    while test -n "$path" -a "$path" != "/"
    do
        test -e "$path/$name" && {
            path_locals="$path_locals $path/$name"
        }
        test "$path" = "$stop_at" && {
            break
        }
        path=$(dirname $path)
    done
}

c_test_find_path_locals()
{
    htd_find_path_locals table.names $1
    echo path_locals=$path_locals

    htd_find_path_locals table.names $1 $(pwd)
    echo path_locals=$path_locals
}
# 
c_fsck()
{
	c_ck_validate sha1
}

c_make()
{
	cd $HTDIR && make $*
}
c_mk()
{
	c_make $*
}

# Run a sys-* target in the main htdocs dir.
c_make_sys()
{
	cd $HTDIR
	for x in $*
	do
		make system-$x
	done
}

c_stat()
{
	c_make stat
}
c_st()
{
	c_stat $*
}

# experiment rewriting console output
clear_lines()
{
	count=$1
	[ -n "$count" ] || count=0

	while [ "$count" -gt -1 ]
	do
		# move forward to end, then erase one line
		echo -ne "\033[200C"
		echo -ne "\033[1K"
		# move up 
		echo -ne "\033[1A"
		count=$(( $count - 1 ))
	done

	# somehow col is one off, ie. the next regular echo has the first character
	# eaten by the previous line. clean one line here
	echo
}
capture_and_clear()
{
	tee /tmp/htd-out
	mv /tmp/htd-out /tmp/htd-out.tmp
	fold -s -w $cols /tmp/htd-out.tmp > /tmp/htd-out
	lines=$(wc -l /tmp/htd-out|awk '{print $1}')
	clear_lines $lines
	echo Captured $lines lines
}
c_build()
{
	rm -f /tmp/htd-out
	c_make build 2>1 | capture_and_clear
	echo Mixed output::
	echo
	cat /tmp/htd-out | sed  's/^/    /'
}

uname=$(uname)
filesize()
{
	case "$uname" in
		Darwin )
			stat -f '%z' "$@" || return 1
			;;
		Linux )
			stat -c '%s' "$@" || return 1
			;;
	esac
}

# show htd shell aliases
c_alias()
{
	grep '\<'$scriptname'\>' ~/.alias | grep -v '^#' | while read _a A
	do
		a_id=$(echo $A | awk -F '=' '{print $1}')
		a_shell=$(echo $A | awk -F '=' '{print $2}')
		echo -e "   $a_id     \t$a_shell"
	done
}

# Open an editor to edit todays log
c_vtoday()
{
	c_make vtoday
}
c_vt()
{
	c_vtoday $*
}

# update yesterday, today and tomorrow links
c_today()
{
    test -z "$1" && P=journal || P=$1
    YSEP=/
    Y=%Y
    MSEP=-
    M=%m
    DSEP=-
    D=%d
    EXT=.rst
    r=$P$YSEP
    p=$P$YSEP$Y$MSEP$M$DSEP$D$EXT
    today=$(date +$p)
    tomorrow=$(date -v +1d +$p)
    yesterday=$(date -v -1d +$p)
    for tag in today tomorrow yesterday
    do
        tp=${r}$tag$EXT
        test -L $tp && {
            echo -n "Deleting "
            rm -v $tp
        }
        # FIXME:mkrlink
        mkrlink $(eval echo \$$tag) $tp
    done
        
}

mkrlink()
{
    # TODO: find shortest relative path
    echo -n "Linking "
    ln -vs $(basename $1) $2
}

# VirtualBox

vbox_names=~/.conf/vbox/vms.sh
c_vbox()
{
	name=$1
	[ -z "$name" ] && {
		c_vbox_list
	} || {
		declare $(echo $(cat $vbox_names))
		uuid=$(eval echo \$$name)
		test -n "$uuid" || err "No such vbox VM '$name'" 1
	}
}

c_vbox_start()
{
	c_vbox $1
	VBoxManage startvm ${uuid} --type headless \
	    && log "Headless-start of VM $name completed successfully"
}

c_vbox_start_console()
{
	c_vbox $1
	VBoxManage startvm ${uuid} \
	    && log "Headless-start of VM $name completed successfully"
}

c_vbox_reset()
{
	c_vbox $1
	VBoxManage controlvm ${uuid} reset \
	    && log "Reset of VM $name completed successfully"
}

c_vbox_stop()
{
	c_vbox $1
	VBoxManage controlvm ${uuid} poweroff \
	    && log "Power-off of VM $name completed successfully"
}

c_vbox_suspend()
{
	c_vbox $1
	VBoxManage controlvm ${uuid} savestate \
	    && log "Save-state of VM $name completed successfully"
}

c_vbox_list()
{
	VBoxManage list vms | \
		sed 's/^"\(.*\)"\ {\(.*\)}$/\2 \1/' | while read uuid name
	do
		grep $uuid $vbox_names >> /dev/null || echo unknown $name =$uuid
	done
	cat $vbox_names | \
		grep -Ev '^\s*(#.*|\s*)$'
}

c_vbox_running()
{
	VBoxManage list runningvms
}

# Wake a remote host using its ethernet address
wol_hwaddr=~/.conf/wol/hosts-hwaddr.sh
c_wol_list_hosts()
{
	cat $wol_hwaddr
	err "Expected hostname argument" 2
}
c_wol()
{
	host=$1
	[ -z "$host" ] && {
		c_wol_list_hosts
	} || {
		declare $(echo $(cat $wol_hwaddr))
		hwaddr=$(eval echo \$$host)
		[ -n "$hwaddr" ] || exit 4
		wakeonlan $hwaddr
		echo ":WOL Host: \`$host <$hwaddr>\`_"
	}
}

# Simply list ARP-table, may want something better like arp-scan or an nmap
# script
c_mac()
{
	arp -a
}

# Experimenting with gtasks.. looking at todo targets
c_todo()
{
	echo
	echo "..Htdocs ToDo.."
	gtasks -L -dsc -dse -sn
	echo "Due:"
	gtasks -L -sdo -dse -sn
#	echo ""
#	gtasks -L -sb tomorrow -sa today -dse
}


# Lists and tasks

c_tasks()
{
    gtasks -L -b
}

c_lists()
{
    gtasks -ll -b
}

c_new_task()
{
    gtasks -l Standaardlijst -a - -t "$@"
}


# init or list SSH based remote 

source_git_remote()
{
    source ~/.conf/git-remotes/$HTD_GIT_REMOTE.sh || err "Missing HTD_GIT_REMOTE=$HTD_GIT_REMOTE script" 1
}

c_git_remote_info()
{
    source_git_remote
    echo remote.$HTD_GIT_REMOTE.dir=$remote_dir
    echo remote.$HTD_GIT_REMOTE.host=$remote_host
    echo remote.$HTD_GIT_REMOTE.user=$remote_user
}
c_git_remote()
{
    source_git_remote
    [ -z "$1" ] && {
        ssh_cmd="cd $remote_dir; ls | grep '.*.git$' | sed 's/\.git$//g' "
        ssh $ssh_opts $remote_user@$remote_host "$ssh_cmd"
    } || {
        repo=$1
        git_url="ssh://$remote_host/~$remote_user/$remote_dir/$repo.git"
        scp_url="$remote_user@$remote_host:$remote_dir/$repo.git"
        echo $git_url
    }
}

c_git_init_remote()
{
    source_git_remote
    [ -n "$1" ] && repo="$1" || repo="$PROJECT"

    ssh_cmd="mkdir -v $remote_dir/$repo.git"
    ssh $remote_user@$remote_host "$ssh_cmd"

    [ -e .git ] || err "No .git directory, stopping remote init" 0

    c_git_remote $repo >> /dev/null

    BARE=../$repo.git
    TMP_BARE=1
    [ -d $BARE ] && TMP_BARE= || {
        [ -d /src/$repo.git ] && {
            TMP_BARE=
            BARE=/src/$repo.git
        } || {
            log "Creating temp. bare clone"
            git clone --bare . $BARE
        }
    }

    [ -n "$TMP_BARE" ] || {
        log "Using existing bare repository to init remote: $BARE"
    }

    log "Syning new bare repo to $scp_url"
    rsync -azu $BARE/ $scp_url
    [ -n "$TMP_BARE" ] && {
        log "Deleting temp. bare clone ($BARE)"
        rm -rf $BARE
    }

    log "Adding new remote, and fetching remote refs"
    git remote add $HTD_GIT_REMOTE $git_url
    git fetch $HTD_GIT_REMOTE

    log "Added remote $HTD_GIT_REMOTE $scp_url"
}

c_git_drop_remote()
{
    [ -n "$1" ] && repo="$1" || repo="$PROJECT"
    log "Checking if repo exists.."
    ssh_opts=-q
    c_git_remote | grep $repo || {
      err "No such remote repo $repo" 1
    }
    source_git_remote
    log "Deleting remote repo $remote_user@$remote_host:$remote_dir/$repo"
    ssh_cmd="rm -rf $remote_dir/$repo.git"
    ssh -q $remote_user@$remote_host "$ssh_cmd"
    log "OK, $repo no longer exists"
}

c_git_largest_objects()
{
	~/bin/git-largest-objects.sh 10
}

# list commits for object sha1
c_git_path_for_object()
{
	blob=$1
	git rev-list --all |
	while read commit; do
		if git ls-tree -r $commit | grep -q $blob; then
			echo $commit
		fi
	done
}

# print tree, blob, commit, etc. objs
c_git_list_objects()
{
	git verify-pack -v .git/objects/pack/pack-*.idx
}

c_git_object_contents()
{
	git cat-file -p $1
}

c_git_annex_unused()
{
	git annex unused | \
		grep '\s\s*[0-8]\+\ \ *.*$' | \
	while read line;
	do
		echo $line
	done
}

c_git_annex_show_unused()
{
	c_git_annex_unused | while read num key
	do
		echo "GIT log for '$key'"
		git log --stat -S"$key"
	done
}
c_git_annex_clear_unused()
{
	test -z "$1" && {
		local cnt
		cnt="$(c_git_annex_unused | tail -n 1 | cut -f 1 -d ' ')"
		c_git_annex_unused | while read num key
		do
			echo $num $key
		done
		echo cnt=$cnt
		read -p 'Delete all? [yN] ' -n 1 user
		echo
		test "$user" = 'y' && {
			while test "$cnt" -gt 0
			do
				git annex dropunused --force $cnt
				cnt=$(( $cnt -1 ))
			done
		} || {
			err 'Cancelled' 1
		}
	} || {
		git annex move --unused --to $1
	}
}

# indexing, cleaning

htd_name_precaution() {
	echo "$@" | grep -E '^[]\[{}\(\)A-Za-z0-9\.,!@#&%*?:'\''\+\ \/_-]*$' > /dev/null || return 1
}

c_test_name()
{
	match_grep_pattern_test "$@"
	htd_name_precaution "$@"
}

c_find_empty()
{
	eval find . $find_ignores -o -size 0 -a -print
}

# TODO interactive file process
c_check()
{
	log "Looking for unknown files.."
	eval find . $find_ignores -o -print \
		| while read p
		do
			c_test_name "$p" >> /dev/null || {
				err "Unhandled characters: $p"
				continue
			}
			[ -L "$p" ] && {
				BE="$(dirname "$p")/$(readlink "$p")"
				[ -e "$BE" ] || {
					#err "Skip dead symlink"
					continue
				}
				SZ="$(filesize "$BE")"
			} || {
				SZ="$(filesize "$p")"
			}
			if test -d "$p" -a -n "$(c_expand $p.{zip,tar{.gz,.bz2}})"
			then
				log "Skipping unpacked dir $p"
				for ck in ck sha1 md5
				do
					c_ck_table_subtree $ck "$p" | while read p2
					do
						c_ck_table $ck "$p2" >> /dev/null && {
							#c_ck_drop $ck "$p"
							echo "Dropped $ck key for $p"
						}
					done
				done
				continue
			fi
			test "$SZ" -ge "$MIN_SIZE" || {
				#err "File too small: $p"
				continue
			}
		done
}

htd_git_rename()
{
	~/bin/matchbox.py rename "$1" "$2" |
	grep -Ev '^\s*(#.*|\s*)$' |
	while read file_old file_new
	do
		$cmd_pref git mv "$file_old" "$file_new"
	done
}

c_rename_test()
{
	cmd_pref="echo"
	c_rename $@
}

c_rename()
{
	from_pattern="$1"
	to_pattern="$2"
	#$(echo $2 | sed 's/@\([A-Z0-9_]*\)/${\1}/g')
	shift 2
	test -z "$1" && {
		htd_git_rename "$from_pattern" "$to_pattern"
	} || {
		{ for p in $@; do echo $p; done ; echo -e "\l"; } |
		htd_git_rename "$from_pattern" "$to_pattern"
	}
}

# List all paths including dirs
c_list_paths()
{
	req_path_arg "$@"
	eval find $path $find_ignores -o -print
}

c_check_names()
{
	test -z "$1" && d="." || { d="$1"; shift 1; }
	test -z "$1" && valid_tags="" || valid_tags="$@"
	test "${d: -1:1}" = "/" && d="${d:0: -1}"

	test -z "$valid_tags" &&
	log "Looking for unmatched paths in $d" ||
	log "Validating $d, using valid patterns $valid_tags"

	{
		eval find $d "$find_ignores -o \( -type l -o -type f \) -a -print "
		echo "\l"
	} | matchbox.py check-names $valid_tags
}

c_fix_names()
{
	local path_regex names_tables names_table
	req_path_arg "$@"
	match_grep_pattern_test "$path"
	path_regex="$p_"
	match_name_tables "$path"
	htd_find_path_locals table.names $(pwd)
	names_tables=$path_locals
	for names_table in $names_tables
	do
		cat $names_table | grep -Ev '^(#.*|\s*)$' | while read match pattern tag
		do
			echo "$match" | grep '^'$path_regex > /dev/null || continue
			match_name_pattern "$pattern"
			for p in $match
			do
				echo "$p" | grep '^'"$grep_pattern"'$' >> /dev/null && {
					test -n "$tag" && {
						echo matched $tag $p
					} || {
						echo ok $p
					}
				} || test -n "$tag" || {
					echo mismatch $p
				}
			done
		done
	done
}

# parse path and annex metadata using given path

req_arg_pattern="Pattern format"
req_arg_path="Path"

c_name_tags_test()
{
	match_name_vars $@
}

c_name_tags()
{
	local pattern
	req_arg "$1" 'name-tags' 1 pattern && shift 1|| return 1
	req_arg "$1" 'name-tags' 2 path && path="$@" || return 1
	c=0
	test "${path: -1:1}" = "/" && path="${path:0: -1}"
	test -d "$path" && {
		eval find "$path $find_ignores -o \( -type f -o -type l \) -a -print" \
		| while read p
		do
			echo $p
			match_name_vars "$pattern" "$p" 2> /dev/null
			#c=$(( $c + 1 ))
			#echo $c
			#echo
		done
	} || {
		err "Req dir arg" 1
	}
}

c_name_tags_all()
{
	req_arg "$1" 'name-tags-all' 1 path && path="$@" || return 1
	test "${path: -1:1}" = "/" && path="${path:0: -1}"
	test -d "$path" && {
		eval find "$path $find_ignores -o \( -type f -o -type l \) -a -print" \
		| while read p
		do
			match_names "$p"
		done
	} || {
		err "Req dir arg" 1
	}
}

c_update()
{
	for CK in ck sha1 md5
	do
		c_ck_prune $CK
		c_ck_clean $CK
		c_ck_update $CK
	done
}


# Checksums

ck_arg()
{
	test -n "$1"  && CK=$1  || CK=ck
	test -e table.$CK || {
		err "First argument must be CK table extension, no such table: table.$CK" 1
	}
	test -r table.$CK || {
		err "Not readable: table.$CK" 1
	}
	T_CK="$(echo $CK | tr 'a-z' 'A-Z')"
}
ck_write()
{
	ck_arg "$1"
	test -w table.$CK || {
		err "Not writable: table.$CK" 1
	}
}

# Check for path in table
c_ck_table()
{
	# table ext
	ck_arg "$1"
	shift 1
	# second table ext
	test -n "$1" -a -e "table.$CK.$1" && {
		S=$1; shift 1
	} || S=
	# path
	[ -z "$1" ] && {
		cat table.$CK$S | grep -Ev '^\s*(#.*|\s*)$' | \
		while read -a ckline
		do
			test "$CK" = "ck" && {
				cks=${ckline[@]::1}
				sz=${ckline[@]::1}
				p="${ckline[@]:2}"
			} || {
				cks=${ckline[@]::1}
				p="${ckline[@]:1}"
			}
			echo "$cks  $p"
		done
	} || {
		# look for single path
		htd_relative_path "$@"
		match_grep_pattern_test "$relpath"
		grep ".*\ \(\.\/\)\?$p_$" table.$CK$S >> /dev/null && {
			echo ok
		} || {
			echo unknown
			return 1
		}
	}
}

c_ck_table_subtree()
{
	ck_arg "$1"
	shift 1
	test -n "$1" || return 1
	match_grep_pattern_test "$@"
	grep ".*\ $p_.*$" table.$CK | grep -v '^#|\s*$' | while read -a ckline
		do
			test "$CK" = "ck" && {
				cks=${ckline[@]::1}
				sz=${ckline[@]::1}
				p="${ckline[@]:2}"
			} || {
				cks=${ckline[@]::1}
				p="${ckline[@]:1}"
			}
			echo "$cks  $p"
		done
}

ck_update_file()
{
	ck_write "$CK"
	update_file="$@"
	c_test_name "$update_file" >> /dev/null || {
		err "Skip path with unhandled characters"
		return
	}
	test -r "$update_file" || {
		err "Skip path not readable by user"
		return
	}
	test -d "$update_file" && {
		err "Skipped directory path"
		return
	}
	test -L "$update_file" && {
		BE="$(dirname "$update_file")/$(readlink "$update_file")"
		test -e "$BE" || {
			err "Skip dead symlink"
			return
		}
		SZ="$(filesize "$BE")"
	} || {
		SZ="$(filesize "$update_file")"
	}
	test "$SZ" -ge "$MIN_SIZE" || {
		err "File too small: $SZ"
		return
	}
	BN="$(basename "$update_file")"
	# XXX hardcoded to 40-char hexsums ie. sha1
	HAS_CKS="$(echo "$BN" | grep '\b[0-9a-f]\{40\}\b')"
	cks="$(echo "$BN" | grep '\b[0-9a-f]\{40\}\b' |
		sed 's/^.*\([0-9a-f]\{40\}\).*$/\1/g')"
	#EXT="$(echo $BE)"
	test -n "$HAS_CKS" && {
		c_ck_table "$CK" "$update_file" > /dev/null && {
			echo "path found"
		} || {
			grep "$cks" table.$CK > /dev/null && {
				echo "$CK duplicate found or cannot grep path"
				return
			}
			CKS=$(${CK}sum "$update_file" | cut -d' ' -f1)
			test "$cks" = "$CKS" || {
				err "${CK}sum $CKS does not match name $cks from $update_file"
				return
			}
			echo "$cks  $update_file" >> table.$CK
			echo "$cks added"
			return
		}
		return
	} || {
		# TODO prepare to rename, keep SHA1 hashtable
		c_ck_table "$CK" "$update_file" || {
			${CK}sum "$update_file" >> table.$CK
		}
	}
}

ck_update_find()
{
	log "Reading $T_CK, looking for paths '$@'"
	find_p="$@"
	test "${find_p: -1:1}" = "/" && find_p="${find_p:0: -1}"
	eval find "$find_p" $find_ignores -o -print \
	| while read p
		do
			ck_update_file "$p"
		done
}

# find all files, check their names, size and checksum
c_ck_update()
{
	ck_write "$1"
	shift 1
	update_p="$@"
	log "Checking '$update_p'"
	test -z "$update_p"  && {
		ck_update_find . || return 1
		return
	}
	test -d "$update_p"  && {
		ck_update_find "$update_p" || return 2
		return
	}
	test -f "$update_p"  && {
		ck_update_file "$@" || return 3
		return
	}
	test -L "$update_p"  &&  {
		ck_update_file "$@" || return 4
		return
	}
	err "Unknown path '$update_p'" 1
}


c_ck_drop()
{
	ck_write "$1"
	shift 1
	ck_drop "$@"
	req_arg "$1" 'ck-drop' 2 path || return 1
	match_grep_pattern_test "$@"
	cp table.$CK table.$CK.tmp
	cat table.$CK.tmp | grep "^.*$p_$" >> table.$CK.missing
	cat table.$CK.tmp | grep -v "^.*$p_$" > table.$CK
	rm table.$CK.tmp
}

c_ck_validate()
{
	ck_arg "$1"
	shift 1
	test "$CK" = "ck" && {
		checksums table.$CK
	} || {
		${CK}sum -c table.$CK
	}
}

# check file size and cksum
checksums()
{
	test -n "$1"  && T=$1  || T=table.ck
	cat $T | while read cks sz p
	do
		SZ="$(filesize "$p")"
		test "$SZ" = "$sz" || { err "File-size mismatch on '$p'"; continue; }
		CKS="$(cksum "$p" | awk '{print $1}')"
		test "$CKS" = "$cks" || { err "Checksum mismatch on '$p'"; continue; }
		echo "$cks ok"
	done
}

# drop non-existant paths from table, copy to .missing
c_ck_prune()
{
	ck_write "$1"
	shift 1
	log "Pruning missing files from $CK table"
	c_ck_table $CK | while read cks p
	do
		test -e "$p" || {
			c_ck_drop $CK "$p"
			echo "Dropped $CK key $cks for '$p'"
		}
	done
}

# Read checksums from *.{sha1,md5,ck}{,sum}
c_ck_consolidate()
{
	eval "find . $find_ignores -o -name '*.{sha1,md5,ck}{,sum}' -a \( -type f -o -type l \) " -print | while read p
	do
		echo "$p"
	done
}

# try to find files from .missing, or put them in .gone
c_ck_clean()
{
	ck_write "$1"
	shift 1
	test -s "table.$CK.missing" || {
		err "$T_CK.missing table does not exists"
		return
	}
	log "Looking for missing files from $CK table"/
	c_ck_table $CK .missing | while read cks p
	do
		BN="$(basename "$p")"
		NW=$(eval find ./ $find_ignores -o -iname '$BN' -print)
		test -n "$NW" && echo "$BN -> $NW"
	done
	echo 'TODO rewrite ck table path'
}

# TODO consolidate meta
c_ck_metafile()
{
	[ -n "$1" ] && d=$1 || d=.
	CK=sha1
	eval find $d $find_ignores -o -iname \'*.meta\' -print \
	| while read metafile
	do
		ck_mf_p="$(dirname "$metafile")/$(basename "$metafile" .meta)"
		[ -e "$ck_mf_p" ] || {
			echo "missing source file $metafile: $ck_mf_p"
			continue
		}
		cks=$(rsr.py --show-sha1sum-hexdigest "$ck_mf_p" 2> /dev/null)
		c_ck_table "$CK" "$ck_mf_p" && {
			log "$cks found"
		} || {
			CKS=$(${CK}sum "$ck_mf_p" | cut -d' ' -f1)
			#echo CKS=$CKS cks=$cks
			test "$cks" = "$CKS" && {
				log "$CKS ok $ck_mf_p"
			} || {
				err "Corrupt file: $ck_mf_p"
				continue
			}
			echo "$CKS  $ck_mf_p" >> table.$CK
		}
		
	done
}

c_mp3_validate()
{
	eval "find . $find_ignores -o -name "*.mp3" -a \( -type f -o -type l \) -print" \
	| while read p
	do
		SZ=$(filesize "$p")
		test -s "$p" || {
			err "Empty file $p"
			continue
		}
		mp3val "$p"
	done
}


# Utils

. ~/bin/util.sh

# stdio/stderr/exit util
log()
{
	[ -n "$(echo "$*")" ] || return 1;
	echo "[$scriptname.sh:$cmd] $1"
}
err()
{
	[ -n "$(echo "$*")" ] || return 1;
	[ "$VERBOSITY" -ge "1" ] && echo "Error: $1 [$scriptname.sh:$cmd]" 1>&2
	echo "$1 [$scriptname.sh:$cmd]" 1>&2
	[ -n "$2" ] && exit $2
}



# Main

#def_func=c_default

if [ -n "$0" ] && [ $0 != "-bash" ]; then

	# Do something (only) if script invoked as '$scriptname'
	base=$(basename $0 .sh)
	case "$base" in

		$scriptname )

			# function name first as argument,
			cmd=$1
			[ -n "$def_func" -a -z "$cmd" ] \
				&& func=$def_func \
				|| func=$(echo c_$cmd | tr '-' '_')

			# load/exec if func exists
			type $func &> /dev/null && {
				func_exists=1
				load
				shift 1
				pushd_cwdir
				$func $@
				popd_cwdir
			} || {
				# handle non-zero return or print usage for non-existant func
				e=$?
				[ -z "$cmd" ] && {
					load
					c_usage
					err 'No command given, see "help"' 1
				} || {
					[ "$e" = "1" -a -z "$func_exists" ] && {
						load
						c_usage
						err "No such command: $cmd" 1
					} || {
						err "Command $cmd returned $e" $e
						popd_cwdir
					}
				}
			}

			;;

		* )
			log "No frontend for $base"
			;;

	esac
fi

# vim:noet:
