#!/usr/bin/env python
"""
This is not a ledger. Just a balance tracker and some averaging.

.. class-uml::

	Account {
		balance:Integer
		name:String
	}

	Mutation {
		to:Account
		from:Account
		amount:Float
		currency:[EUR]
		date:Date
		description:String
		specification:String
	}

Done
- Read, parse from rabobank csv files
- Print total.
- Read new accounts numbers from files and store, categorize.
- Time-window data, balance correction.

Todo
- Consolidate with DB, currently only reads CSV. categorize mutations first?
- Generate montly tables, weekly. Averages.
- Track each mutation once, index (sqlite) at first read
  (partially implemented)
- Autosort mutations, match rules for expense and income accounts
- Can GNU Cash import anything beyond mutations, 
  and also do autosorting or do I need to rewrite its XML
  document?
- Perhaps schedule payments
- Add some saldo checks, e.g. each month or random to assert correctness anytime

Other ToDo
- Use optparse and proper options, perhaps integrate with framework thingie
- Clean out output writing and design proper options->formatter handling.

"""
import os
import csv
import hashlib
from datetime import datetime

import confparse
from lib import Prompt
from myLedger import get_session, Account, Mutation


mutations = {}

def csv_reader(csvfile, fields, unique_fields=False, unique_records=True, opts=False):
	"""Generator"""
	global mutations
	reader = csv.reader(open(csvfile), delimiter=',')
	line = 0 # csv.reader iteration count
	# prepare for unique_fields
	seen = {}
	if unique_fields: 
		if not isinstance(unique_fields, list):
			unique_fields = fields
		seen = dict(zip( unique_fields, [ [] for n in unique_fields ] ))
	skipping = 0 # track skipping with unique_records
	for row in reader:
		line += 1
		# old and new style records
		if len(row) == 16:
			accnr,curr,date,DC,amount,destacc,destname,date2,cat,_1,descr,descr2,descr3,descr4,_2,_3 = row
		elif len(row) == 19:
			accnr, curr, date, DC, amount, \
					destacc, destname, date2, cat, _1,\
					descr, descr2, descr3, descr4, _2, \
					_3, nr1, accnr2, nr2 = row
			accnr = accnr[8:]
		elif row == ['\x1a']:
			continue#break
		else:
			assert False, len(row)
		# track/skip for unique_records
		if unique_records:
			key = hashlib.sha1(date)
			key.update(accnr)
			key.update(destacc)
			key.update(amount)
			key.update(cat)
			key.update(descr)
			key.update(descr2)
			key = key.hexdigest()
			if key in mutations:
				skipping += 1
				continue
			elif skipping:
				print 'Skipped', skipping, 'lines, %s' % ( csvfile)
				skipping = 0
			mutations[key] = True
		if opts:
			# skip for start/end date
			if opts.start_date:
				start_date = datetime.strptime(opts.start_date, '%Y-%m-%d')
				if start_date >= datetime.strptime(date, '%Y%m%d'):
					#print 'skipped', csvfile, line, date
					continue
			if opts.end_date:
				end_date = datetime.strptime(opts.end_date, '%Y-%m-%d')
				if end_date < datetime.strptime(date, '%Y%m%d'):
					#print 'skipped', csvfile, line, date
					continue
		# parse some..
		amount = float(amount)
		if DC.upper() == 'D':
			amount = 0-amount
		# track changed fields
		new = False
		if seen:
			for i, n in enumerate(unique_fields):
				v = locals()[n]
				if v:
					newnew = new or v not in seen[n]
					if new and not newnew:
						break
					new = newnew
		# yield if new (changed or unique) and everything if not tracking
		if new or not seen:
			if destacc == '0000000000':
				if cat == 'ba':
					pass# betaalautomaat
				elif cat == 'ga':
					pass# geldautomaat
				elif cat == 'ck':
					pass# chipknip, opladen?
				elif cat == 'db':
					pass# kosten bankzaken
				elif descr == 'Rente over periode':
					pass
				else:
					assert False, (destacc, destname, cat, row)
			else:
				assert cat in ('ma', 'ba', 'ga', 'cb', 'id', 'db', 'bg', 'ac', 'ei'), cat

			vs = [ locals()[n] for n in fields ]
			if unique_fields and seen:
				vc = [ locals()[n] for n in unique_fields ]
				for i, v in enumerate(vc):
					n = unique_fields[i]
					seen[n].append(v)
			yield tuple(vs)

def import_accounts_from_file(sa, csvfile, opts):
	reader = csv_reader(csvfile, ['destacc', 'destname'], unique_fields=['destacc'])
	for destacc, destname in reader :
		if destacc == '0000000000' or destacc == '':
			#print "Ignored non account", destacc, destname
			continue
		accounts = sa.query(Account).filter(Account.account_number == destacc ).all()
		if accounts: # got one already
			continue
		# TODO: must set account type
		newAcc = Account(
				account_number=destacc, 
				account_name = destname,
				account_type = 'Expenses')
		sa.add(newAcc)
		sa.commit()
		print destacc, destname
		print sa.query(Account).filter(Account.account_name == destname ).all()
	pass

def detect_source_account(accnr, sa, opts):
	accounts = sa.query(Account).filter(Account.account_number == accnr ).all()
	if accounts:
		return accounts[0]

def import_mutations_from_file(sa, csvfile, opts):
	reader = csv_reader(csvfile, [ 'line', 'date', 'accnr', 'amount', 'destacc', 'cat',
		'destname', 'descr', 'descr2' ])
	for line, date, accnr, amount, destacc, cat, destname, descr, descr2 in reader:

		account = detect_source_account(accnr, sa, opts)
		if not account:
#			print "'From' account unknown", accnr
			continue

		accounts = sa.query(Account).filter( Account.account_number == destacc ).all()
		if not accounts:
#			print "'To' account unknown", line, destacc, cat, destname, descr, descr2
			continue
		destaccount = accounts[0]

		category = ''

		#print csvfile, line, accnr, amount, destacc
		m = Mutation(from_account=account, to_account=destaccount,
				amount=amount, category=category)

def import_from_file(sa, csvfile, opts):
	# XXX: can only do one at a time while global mutations is used
	#import_accounts_from_file(sa, csvfile, opts)
	import_mutations_from_file(sa, csvfile, opts)

def import_from_files(opts, *args):
	for csvfile in args:
		print '# Importing', csvfile
		import_from_file(opts._sa, csvfile, opts)

def print_sum_from_file(csvfile, opts):
	saldo = 0
	line = 0
	for amount, line in csv_reader(csvfile, [ 'amount', 'line'], opts=opts):
		saldo = saldo + amount
	print 'Read', csvfile, line, 'lines'
	return saldo

def print_sum_from_files(opts, *files):
	global mutations
	saldo = 0
	if opts.end_balance:
		for f in files:
			change = print_sum_from_file(f, opts)
			saldo = saldo + change
		correction = opts.end_balance - saldo
		print 'Correction', correction
		saldo = correction
	mutations = {}
	for f in files:
		change = print_sum_from_file(f, opts)
		print 'Change:', change
		saldo = saldo + change
		print 'Subtotal:', saldo
	print 'Total:', saldo

def print_gnu_cash_import_csv(csvfile, description_delimiter='\n', opts=None):
	reader = csv.reader(open(csvfile), delimiter=',')
	for row in reader:
		if len(row) == 16:
			accnr,curr,date,DC,amount,destacc,destname,date2,cat,_,descr,descr2,descr3,descr4,_,_ = row
		elif len(row) == 19:
			accnr, curr, date, DC, amount, \
					destacc, destname, date2, cat, _,\
					descr, descr2, descr3, descr4, _, \
					_, nr1, accnr2, n2 = row
			accnr = accnr[8:]
		elif row == ['\x1a']:
			break
		else:
			assert False, len(row)

		dt = date[:4] +'-'+ date[4:6] +'-'+ date[6:8]
		d = description_delimiter.join([ 
			d for d in descr, descr2, descr3, descr4 if d.strip()])
		debet = DC.upper() == 'D'
		out = dt, debet and amount or "", not debet and amount or "", destacc, destname, d
		print ",".join( map(lambda x: '"%s"' % x, out) )

def list_accounts(opts):
	accounts = opts._sa.query(Account).all()
	for account in accounts:
		print account.account_id, account

def set_account_category(opts, account, category=None):
	# account must exist
	if isinstance(account, basestring):
		account = opts._sa.query(Account).filter(Account.account_number == account).one()
		print account
	if not category:
		if account.account_type == None:
			account.account_type = ''
		ok = False
		while not ok:
			category = Prompt.input("Please enter/update the classification: ",
					account.account_type)
			acctypes = opts._sa.query(Account).filter(Account.account_type == category).first()
			if acctypes:
				ok = True
			elif not acctypes:
				ok = Prompt.ask("Is new category %r correct?" % category, 'yN')
				if not ok:
					if Prompt.query("Cancel?", 'Yn'):
						break
	if category:
		if account.account_type != category:
			account.account_type = category
			opts._sa.add(account)
			opts._sa.commit()
			print "Updated", account

def organize(opts, account=None, category=None):
	opts._sa = sa = get_session(opts.dbref)	
	if account:
		set_account_category(opts, account, category)
	else:
		accounts = sa.query(Account).all()
		for account in accounts:
			print account
			set_account_category(opts, account)
	
def drop_account(opts, account):
	sa = get_session(opts.dbref)	
	acc = sa.query(Account).filter(Account.account_number == account).one()
	sa.delete(acc)
	sa.commit()
	print "Dropped account", account, acc

def reset_db(opts):
	dbfile = os.path.expanduser(opts.dbrefname)
	if os.path.exists(dbfile):
		os.remove(dbfile)
		print 'Deleted myLedger database'
	get_session(opts.dbref, True)	

def main():
	import sys
	from getopt import getopt
	opts, args = getopt(sys.argv[1:], 'hl:g', [
		'list-accounts',
		'delete-account',
		'organize',
		'reset-db',
#		'ledger-dbname=', 
#		'ledger-db=',
		'import',
		'print-mutations-csv',
		'gnu-cash-csv',
		'start-date=',
		'end-date=',
		'start-balance=',
		'end-balance=',
	])
	settings = confparse.Values(dict(
		start_date=None, end_date=None, 
		start_balance=None, end_balance=None
	))
	settings.dbrefname = '~/.myLedger.sqlite'
	settings.dbref = 'sqlite:///%s' % os.path.expanduser(settings.dbrefname)
	settings._sa = sa = get_session(settings.dbref)	
	# options should be in sequence, one command at the end
	cmd, cargs = None, ()
	for o in opts:
		if '--gnu-cash-csv' in o:
			for a in args:
				print_gnu_cash_import_csv(a, '\t', settings)
			return
		elif '--start-balance' in o:
			print >>sys.stderr, "Warning: start-balance option ignored "
		elif '--start-date' in o:
			settings.start_date = o[1]
		elif '--end-date' in o:
			settings.end_date = o[1]
		elif '--end-balance' in o:
			settings.end_balance = float(o[1])
		elif '--print-mutations-csv' in o:
			cmd, cargs = 'print_sum_from_files', [settings, ] + args
		# 
		elif '--import' in o:
			cmd, cargs = 'import_from_files', [settings, ] + args
		# DB commands
		elif '--reset-db' in o:
			cmd, cargs = 'reset_db', (settings, ) 
		# Account commands
		elif '--import-accounts' in o:
			sa = get_session(opts.dbref)
			for a in args:
				import_accounts_from_file(sa, a, settings)
			return
		elif '--organize' in o:
			cmd, cargs = 'organize', [settings, ] + args
		elif '--list-accounts' in o:
			cmd, cargs = 'list_accounts', (settings, )
		elif '--delete-account' in o:
			cmd, cargs = 'drop_account', [settings, ] + args

	if cmd in globals():
		return globals()[cmd](*cargs)
	else:
		print >>sys.stderr, "Command not found. "
		return -1

if __name__ == '__main__':
	main()

