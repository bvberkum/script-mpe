#!/usr/bin/env python
"""
:created: 2015-11-30

Python helper to query/update projects.yaml

Usage:
    projectdir-meta [options] put-repo <prefix> [<kwdargs>...]
    projectdir-meta [options] update-repo <prefix> [<kwdargs>...]
    projectdir-meta [options] drop-repo <prefix>
    projectdir-meta [options] (enabled|disabled) <prefix>
    projectdir-meta [options] (enable|disable) <prefix>
    projectdir-meta [options] clean-mode <prefix> [<mode>]
    projectdir-meta [options] list-prefixes [<root>]
    projectdir-meta [options] list-enabled [<root>]
    projectdir-meta [options] list-disabled [<root>]
    projectdir-meta [options] [(dump|x-dump) [<prefix>]]
    projectdir-meta [options] get-uri <prefix> [<remote>]
    projectdir-meta [options] list-remotes <prefix>
    projectdir-meta [options] list-upstream <prefix> [<branches>...]
    projectdir-meta [options] conv
    projectdir-meta (-h | --help)

Options:
  -q, --quiet   Quiet operations
  -s, --strict  Strict operations
  -g, --glob    Change from root prefix matching to glob matching.
  -f PD, --file PD
                Give custom path to projectdir document file [default: ./projects.yaml]
"""
import os
from fnmatch import fnmatch

from docopt import docopt
import uuid

from deep_eq import deep_eq

from script_mpe import util

from script_mpe.res import js
from script_mpe.confparse import yaml_load, yaml_safe_dump


def meta_from_projectdir_doc(data):
    newdata = {}

    for prefix in data['repositories'].keys():

        remotes = dict( data['repositories'][prefix]['remotes'] )
        repoid = "repo:_:%s" % uuid.uuid4()
        newdata[repoid] = dict(
            prefix=prefix,
            remotes=remotes
        )
    return newdata


toggle_states = 'disabled', 'enabled'

def toggle(state):
    if state == toggle_states[0]:
        return toggle_states[1]
    else:
        return toggle_states[0]

def toggle_active(state):
    return state == toggle_states[1]

def toggle_inactive(state):
    return state == toggle_states[0]

def get_toggle_state(data):
    for state in toggle_states:
        if state in data:
            if data[state]:
                return state
            else:
                return toggle(state)

def set_toggle_state(data, state):
    assert state in toggle_states

    if toggle(state) in data:
        del data[toggle(state)]

    enabled = state == toggle_states[1]

    data[state] = True


repo_modes = ['tracked', 'untracked', 'excluded']

def get_clean_mode(repo):
    """Clean mode is 'tracked' to only consider changes to tracked files,
    untracked to include those as well, or excluded to consider all files in
    the checkout directory including GIT ignored files.
    """
    if 'clean' in repo:
        repo_mode = repo['clean']
    else:
        repo_mode = True
    if isinstance(repo_mode, bool):
        if repo_mode == True:
            repo_mode = 'untracked'
        else:
            repo_mode = 'tracked'
    return repo_mode


def prefix_match(prefix, match, opts):
    """Match path <prefix> with root-path or pattern <match> """
    if match:
        if opts.flags.glob:
            return fnmatch( prefix, match )
        else:
            return prefix.startswith( match )

        return False
    else:
        return True



def main(pd_doc, func=None, opts=None):
    pdhdata = yaml_load(open(pd_doc))

    # Project repo Enabled/Disabled function
    if func in ('enabled', 'disabled'):
        prefix = opts.args.prefix
        state = get_toggle_state(pdhdata['repositories'][prefix])
        if not opts.flags.quiet:
            print "%s\t%s" % ( prefix, state )
        if opts.flags.strict and not state:
            return
        if func != state:
            return 1

    elif func in ('enable', 'disable'):
        prefix = opts.args.prefix
        state = get_toggle_state(pdhdata['repositories'][prefix])
        if func+'d' != state:
            set_toggle_state( pdhdata['repositories'][prefix], func+'d' )
            yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    # Return or check for clean-mode
    elif func == 'clean-mode':
        mode = opts.args.mode or 'untracked'
        if opts.args.prefix in pdhdata['repositories']:
            repo = pdhdata['repositories'][opts.args.prefix]
            repo_mode = get_clean_mode(repo)
            if opts.flags.strict:
                return repo_mode == mode
            else:
                if opts.flags.strict:
                    if repo_mode != mode:
                        return 1
                else:
                    if repo_modes.index(repo_mode) < repo_modes.index(mode):
                        return 1
        else:
            for k in pdhdata['repositories'].keys():
                if not prefix_match( k, opts.args.prefix, opts ):
                    continue
                repo = pdhdata['repositories'][k]
                repo_mode = get_clean_mode(repo)
                if opts.flags.strict:
                    if repo_mode != mode:
                        return 1
                else:
                    if repo_modes.index(repo_mode) < repo_modes.index(mode):
                        return 1

    # add/update/drop repo metadata
    elif func in ('put-repo', 'update-repo'):

        new = dict([ k.split('=') for k in opts.args.kwdargs ])
        for k,v in new.items():
            if v == 'true':
                new[k] = True
            elif v == 'false':
                new[k] = False
            elif v.isdigit():
                new[k] = int(v)

        p = opts.args.prefix
        if func == 'update-repo':
            if p not in pdhdata['repositories']:
                print "No such repo prefix", p
                return 2
            updated = dict(pdhdata['repositories'][p])
            updated.update(new)
            if deep_eq( pdhdata['repositories'][p], updated ):
                return 42
            pdhdata['repositories'][p] = updated
        else:
            if p in pdhdata['repositories']:
                print "Pepo prefix exists", p
                return 3
            pdhdata['repositories'][p] = new

        yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    elif func == 'drop-repo':
        p = opts.args.prefix
        del pdhdata['repositories'][p]
        yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    # List all project repo prefixes
    elif func == 'list-prefixes':
        for k in pdhdata['repositories'].keys():
            if prefix_match( k, opts.args.root, opts ):
                print k

    elif func in ( 'list-enabled', 'list-disabled' ):
        for k in pdhdata['repositories'].keys():
            if not prefix_match( k, opts.args.root, opts ):
                continue
            state = get_toggle_state(pdhdata['repositories'][k])
            if state is None:
                continue
            bstate = toggle_active(state)
            if bstate:
                if func == 'list-enabled':
                    print k
            elif func == 'list-disabled':
                print k

    elif func == 'conv':
        newd = dict(repositories={})
        for k, v in pdhdata['repositories'].items():
            sd = {}
            r = {}
            for sk, sv in pdhdata['repositories'][k].items():
                if sk in ('enabled', 'disabled', 'title', 'description', 'clean'):
                    sd[sk] = sv
                else:
                    r[sk] = sv
                #if sk in ('origin', 'original', 'brix', 'dotmpe')
            sd['remotes'] = r
            newd['repositories'][k] = sd

        yaml_safe_dump(newd, open(pd_doc, 'w+'), default_flow_style=False)

    elif func == 'list-upstream':
        repos = pdhdata['repositories']
        assert opts.args.prefix in repos, "No key %s" %opts.args.prefix

        branches = 'branches' in opts.args and opts.args.branches
        if not branches: branches = '*'
        sync = None
        if 'sync' in repos[opts.args.prefix]:
            sync = repos[opts.args.prefix]['sync']

        if not sync:
            if sync == None and opts.flags.strict:
                return 1
            return

        if isinstance(sync, list):
            for remote in sync:
                for branch in branches:
                    print remote, branch
        elif isinstance(sync, bool):
            for remote in repos[opts.args.prefix]['remotes']:
                for branch in branches:
                    print remote, branch

    elif func == 'list-remotes':
        repos = pdhdata['repositories']
        assert opts.args.prefix in repos, "No key %s" %opts.args.prefix
        for remote in repos[opts.args.prefix]['remotes']:
            print remote

    elif func == 'get-uri':
        repos = pdhdata['repositories']
        assert opts.args.prefix in repos, "No key %s" %opts.args.prefix
        remote = 'origin'
        if 'remote' in opts.args:
            remote = opts.args.remote or 'origin'
        remotes = repos[opts.args.prefix]['remotes']
        assert remote in remotes
        print remotes[remote]

    elif func == 'dump':
        if 'prefix' not in opts.args:
            print yaml_safe_dump(pdhdata, default_flow_style=False)
        else:
            print "repositories:"
            for k in pdhdata['repositories'].keys():
                if not prefix_match( k, opts.args.prefix, opts ):
                    continue
                print "  %s:" % k
                v = pdhdata['repositories'][k]
                print "   ", yaml_safe_dump(v, default_flow_style=False).replace(
                        '\n', '\n    ')

    elif func == 'x-dump':
        meta = meta_from_projectdir_doc(pdhdata)
        print yaml_safe_dump(meta, default_flow_style=False)



if __name__ == '__main__':
    import sys
    opts = util.get_opts(__doc__)
    if not opts.cmds: opts.cmds = ['dump']
    sys.exit( main( opts.flags.file, opts.cmds[0], opts ) )

