#!/usr/bin/env python
"""
:created: 2015-11-30

Read from human-maintained document into processable structure.

Usage:
    projectdir-meta [options] put-repo <prefix> [<kwdargs>...]
    projectdir-meta [options] update-repo <prefix> [<kwdargs>...]
    projectdir-meta [options] drop-repo <prefix>
    projectdir-meta [options] (enabled|disabled) <prefix>
    projectdir-meta [options] (enable|disable) <prefix>
    projectdir-meta [options] clean-mode <prefix> [<mode>]
    projectdir-meta [options] list-prefixes [<root>]
    projectdir-meta [options] list-enabled [<root>]
    projectdir-meta [options] list-disabled [<root>]
    projectdir-meta [options] [(dump|x-dump)]
    projectdir-meta [options] conv
    projectdir-meta (-h | --help)

Options:
  -q, --quiet   Quiet operations
  -s, --strict  Strict operations
  -f PD, --file PD
                Give custom path to projectdir document file [default: ./projects.yaml]
"""
import os

from docopt import docopt
import uuid

from deep_eq import deep_eq

from script_mpe import util

from script_mpe.res import js
from script_mpe.confparse import yaml_load, yaml_safe_dump


def meta_from_projectdir_doc(data):
    newdata = {}

    for prefix in data['repositories'].keys():

        remotes = dict( data['repositories'][prefix]['remotes'] )
        repoid = "repo:_:%s" % uuid.uuid4()
        newdata[repoid] = dict(
            prefix=prefix,
            remotes=remotes
        )
    return newdata


toggle_states = 'disabled', 'enabled'

def toggle(state):
    if state == toggle_states[0]:
        return toggle_states[1]
    else:
        return toggle_states[0]

def toggle_active(state):
    return state == toggle_states[1]

def toggle_inactive(state):
    return state == toggle_states[0]

def get_toggle_state(data):
    for state in toggle_states:
        if state in data:
            if data[state]:
                return state
            else:
                return toggle(state)

def set_toggle_state(data, state):
    assert state in toggle_states

    if toggle(state) in data:
        del data[toggle(state)]

    enabled = state == toggle_states[1]

    data[state] = True


repo_modes = ['tracked', 'untracked', 'excluded']

def get_clean_mode(repo):
    """Clean mode is 'tracked' to only consider changes to tracked files,
    untracked to include those as well, or excluded to consider all files in
    the checkout directory including GIT ignored files.
    """
    if 'clean' in repo:
        repo_mode = repo['clean']
    else:
        repo_mode = True
    if isinstance(repo_mode, bool):
        if repo_mode == True:
            repo_mode = 'untracked'
        else:
            repo_mode = 'tracked'
    return repo_mode


def main(pd_doc, func=None, opts=None):
    pdhdata = yaml_load(open(pd_doc))

    # Project repo Enabled/Disabled function
    if func in ('enabled', 'disabled'):
        prefix = opts.args.prefix
        state = get_toggle_state(pdhdata['repositories'][prefix])
        if not opts.flags.quiet:
            print "%s\t%s" % ( prefix, state )
        if opts.flags.strict and not state:
            return
        if func != state:
            return 1

    elif func in ('enable', 'disable'):
        prefix = opts.args.prefix
        state = get_toggle_state(pdhdata['repositories'][prefix])
        if func+'d' != state:
            set_toggle_state( pdhdata['repositories'][prefix], func+'d' )
            yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    # Return or check for clean-mode
    elif func == 'clean-mode':
        mode = opts.args.mode or 'untracked'
        if opts.args.prefix in pdhdata['repositories']:
            repo = pdhdata['repositories'][opts.args.prefix]
            repo_mode = get_clean_mode(repo)
            if opts.flags.strict:
                return repo_mode == mode
            else:
                if opts.flags.strict:
                    if repo_mode != mode:
                        return 1
                else:
                    if repo_modes.index(repo_mode) < repo_modes.index(mode):
                        return 1
        else:
            for x in pdhdata['repositories'].keys():
                if not x.startswith(opts.args.prefix):
                    continue
                repo = pdhdata['repositories'][x]
                repo_mode = get_clean_mode(repo)
                if opts.flags.strict:
                    if repo_mode != mode:
                        return 1
                else:
                    if repo_modes.index(repo_mode) < repo_modes.index(mode):
                        return 1

    # add/update/drop repo metadata
    elif func in ('put-repo', 'update-repo'):

        new = dict([ k.split('=') for k in opts.args.kwdargs ])
        for k,v in new.items():
            if v == 'true':
                new[k] = True
            elif v == 'false':
                new[k] = False
            elif v.isdigit():
                new[k] = int(v)

        p = opts.args.prefix
        if func == 'update-repo':
            if p not in pdhdata['repositories']:
                print "No such repo prefix", p
                return 2
            updated = dict(pdhdata['repositories'][p])
            updated.update(new)
            if deep_eq( pdhdata['repositories'][p], updated ):
                return 42
            pdhdata['repositories'][p] = updated
        else:
            if p in pdhdata['repositories']:
                print "Pepo prefix exists", p
                return 3
            pdhdata['repositories'][p] = new

        yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    elif func == 'drop-repo':
        p = opts.args.prefix
        del pdhdata['repositories'][p]
        yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    # List all project repo prefixes
    elif func == 'list-prefixes':
        for x in pdhdata['repositories'].keys():
            if opts.args.root and not x.startswith(opts.args.root):
                continue
            print x

    elif func in ( 'list-enabled', 'list-disabled' ):
        for x in pdhdata['repositories'].keys():
            if opts.args.root and not x.startswith(opts.args.root):
                continue
            state = get_toggle_state(pdhdata['repositories'][x])
            if state is None:
                continue
            bstate = toggle_active(state)
            if bstate:
                if func == 'list-enabled':
                    print x
            elif func == 'list-disabled':
                print x

    elif func == 'conv':
        newd = dict(repositories={})
        for k, v in pdhdata['repositories'].items():
            sd = {}
            r = {}
            for sk, sv in pdhdata['repositories'][k].items():
                if sk in ('enabled', 'disabled', 'title', 'description', 'clean'):
                    sd[sk] = sv
                else:
                    r[sk] = sv
                #if sk in ('origin', 'original', 'brix', 'dotmpe')
            sd['remotes'] = r
            newd['repositories'][k] = sd

        yaml_safe_dump(newd, open(pd_doc, 'w+'), default_flow_style=False)

    elif func == 'dump':
        print yaml_safe_dump(pdhdata, default_flow_style=False)

    elif func == 'x-dump':
        meta = meta_from_projectdir_doc(pdhdata)
        print yaml_safe_dump(meta, default_flow_style=False)



if __name__ == '__main__':
    import sys
    opts = util.get_opts(__doc__)
    if not opts.cmds: opts.cmds = ['dump']
    sys.exit( main( opts.flags.file, opts.cmds[0], opts ) )

