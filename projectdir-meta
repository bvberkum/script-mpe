#!/usr/bin/env python
"""
:created: 2015-11-30

Read from human-maintained document into processable structure.

Usage:
    projectdir-meta [options] add-repo <prefix> [<kwdargs>...]
    projectdir-meta [options] update-repo <prefix> [<kwdargs>...]
    projectdir-meta [options] drop-repo <prefix>
    projectdir-meta [options] list-prefixes [<root>]
    projectdir-meta [options] (enabled|disabled) <prefix>
    projectdir-meta [options] clean-mode <prefix> [<mode>]
    projectdir-meta (-h | --help)

Options:
  -q, --quiet   Quiet operations
  -s, --strict  Strict operations
  -f PD, --file PD
                Give custom path to projectdir document file [default: ./projects.yaml]
"""
import os

from docopt import docopt
import uuid

from deep_eq import deep_eq

from script_mpe import util

from script_mpe.res import js
from script_mpe.confparse import yaml_load, yaml_safe_dump


def meta_from_projectdir_doc(data):
    newdata = {}

    for prefix in data['repositories'].keys():

        remotes = []
        for rname, rurl in data['repositories'][prefix].items():
            remotes.append(dict(
                name=rname, url=rurl
            ))
        repoid = "repo:_:%s" % uuid.uuid4()
        newdata[repoid] = dict(
            prefix=prefix,
            remotes=remotes
        )
    return newdata


toggle_states = 'disabled', 'enabled'

def toggle(state):
    if state == toggle_states[0]:
        return toggle_states[1]
    else:
        return toggle_states[0]

def get_toggle_state(data):
    for state in toggle_states:
        if state in data:
            if data[state]:
                return state
            else:
                return toggle(state)

repo_modes = ['tracked', 'untracked', 'excluded']

def get_clean_mode(repo):
    """Clean mode is 'tracked' to only consider changes to tracked files,
    untracked to include those as well, or excluded to consider all files in
    the checkout directory including GIT ignored files.
    """
    if 'clean' in repo:
        repo_mode = repo['clean']
    else:
        repo_mode = True
    if isinstance(repo_mode, bool):
        if repo_mode == True:
            repo_mode = 'untracked'
        else:
            repo_mode = 'tracked'
    return repo_mode


def main(pd_doc, func=None, opts=None):
    pdhdata = yaml_load(open(pd_doc))

    # Project repo Enabled/Disabled function
    if func in ('enabled', 'disabled'):
        prefix = opts.args.prefix
        state = get_toggle_state(pdhdata['repositories'][prefix])
        if not opts.flags.quiet:
            print "%s\t%s" % ( prefix, state )
        if opts.flags.strict and not state:
            return
        if func != state:
            return 1

    # Return or check for clean-mode
    elif func == 'clean-mode':
        mode = opts.args.mode or 'untracked'
        if opts.args.prefix in pdhdata['repositories']:
            repo = pdhdata['repositories'][opts.args.prefix]
            repo_mode = get_clean_mode(repo)
            if opts.flags.strict:
                return repo_mode == mode
            else:
                if opts.flags.strict:
                    if repo_mode != mode:
                        return 1
                else:
                    if repo_modes.index(repo_mode) < repo_modes.index(mode):
                        return 1
        else:
            for x in pdhdata['repositories'].keys():
                if not x.startswith(opts.args.prefix):
                    continue
                repo = pdhdata['repositories'][x]
                repo_mode = get_clean_mode(repo)
                if opts.flags.strict:
                    if repo_mode != mode:
                        return 1
                else:
                    if repo_modes.index(repo_mode) < repo_modes.index(mode):
                        return 1

    # add/update/drop repo metadata
    elif func == 'add-repo':
        p = opts.args.prefix
        pdhdata['repositories'][p] =\
            dict([ k.split('=') for k in opts.args.kwdargs ])
        yaml_safe_dump(pdhdata, open(pd_doc, 'a+'), default_flow_style=False)

    elif func == 'update-repo':
        p = opts.args.prefix
        if p not in pdhdata['repositories'] and not p.endswith(os.sep):
            p += os.sep
        if p not in pdhdata['repositories'] and not p.startswith('.'+os.sep):
            p = '.'+os.sep+p
        if p not in pdhdata['repositories']:
            print "No such repo prefix", p
            return 2
        new = dict([ k.split('=') for k in opts.args.kwdargs ])
        for k,v in new.items():
            if v == 'true':
                new[k] = True
            elif v == 'false':
                new[k] = False
            elif v.isdigit():
                new[k] = int(v)
        updated = dict(pdhdata['repositories'][p])
        updated.update(new)
        if deep_eq( pdhdata['repositories'][p], updated ):
            return 42
        pdhdata['repositories'][p] = updated
        yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    elif func == 'drop-repo':
        p = opts.args.prefix
        del pdhdata['repositories'][p]
        yaml_safe_dump(pdhdata, open(pd_doc, 'w+'), default_flow_style=False)

    # List all project repo prefixes
    elif func == 'list-prefixes':
        for x in pdhdata['repositories'].keys():
            if opts.args.root and not x.startswith(opts.args.root):
                continue
            print x

    else:
        meta = meta_from_projectdir_doc(pdhdata)
        print yaml_safe_dump(meta)



if __name__ == '__main__':
    import sys
    opts = util.get_opts(__doc__)
    #print opts.todict()
    sys.exit( main( opts.flags.file, opts.cmds[0], opts ) )

