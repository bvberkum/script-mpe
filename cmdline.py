"""cmdline

Command line handling for target.

    Handler
     - &func (callable that returns generator)
     - prerequisites (static)
     - requires (dynamic)
     
    Target:ITarget
     - @key (name.qname)
     - &name:Name
     - &handler:Handler
     - graph:Graph
    
    OptionParser
    Prompt
    Command

"""
import inspect
import optparse
import os
import sys
import re
from UserDict import UserDict
from UserList import UserList

import zope.interface

import confparse
import lib
import log
import res
from target import Namespace, Name, Target


NS = Namespace.register(
    prefix='cmd',
    uriref='http://project.dotmpe.com/script/#/cmdline'
)


class OptionParser(optparse.OptionParser):
    
    def __init__(self, usage, version=None):
        optparse.OptionParser.__init__(self, usage, version=version)
        self._targets = None

    def print_help(self, file=None):
        if file is None:
            file = sys.stdout
        encoding = self._get_encoding(file)
        file.write(self.format_help().encode(encoding, "replace"))
        log.info("%s options", len(self.option_list))
        print >> file
        self.print_targets(fl=file)

    @property
    def targets(self):
        """
        Instance property for convenience.
        """
        if not self._targets:
            self._targets = Target.instances.keys()
            self._targets.sort()
        return self._targets
    
    def print_targets(self, fl=None):
        targets = self.targets
        print >>fl, "Targets: "
        for target in targets:
            print >>fl, '  -', target
        print >>fl, len(targets), 'targets'


def optparse_decrement_message(option, optstr, value, parser):
    "Lower output-message threshold. "
    parser.values.quiet = False
    parser.values.messages -= 1

def optparse_override_quiet(option, optstr, value, parser):
    "Turn off non-essential output. "
    parser.values.quiet = True
    parser.values.interactive = False
    parser.values.messages = 4 # skip warning and below

def optparse_print_help(options, optstr, value, parser):
    parser.print_help()


class Prompt(object):

    @classmethod
    def ask(clss, question, yes_no='Yn'):
        yes, no = yes_no.split()
        assert yes.isupper() or no.isupper()
        v = raw_input('%s [%s] ' % (question, yes_no))
        if not v:
            if yes.isupper():
                v = yes
            else:
                v = no
        elif v.upper() not in yes_no.upper():
            return
        return v.upper() == yes.upper()

    @classmethod
    def query(clss, question, options=()):
        assert options
        opts = ''.join([o[0] for o in options]).title()
        while True:
            v = raw_input('%s [%s] or [?help] ' % (question, opts)).strip()
            if not v:
                v = opts[0]
            if v == 'help'  or v in '?h':
                print ("Choose from %s. Default is %r, use --recurse option to "
                    "override. ") % (', '.join(options), options[0])
            if v.upper() in opts.upper():
                choice = opts.upper().index(v.upper())
                print 'Answer:', options[choice] 
                return choice


class Handler(object):

    def __init__(self, func=None, prerequisites=[], requires=[], results=[]):
        self.func = func
        self.prerequisites = prerequisites
#        self.requires = requires
#        self.results = results


class Targets(tuple):
    def __init__(self, *args):
        self.required = False
        tuple.__init__(self, *args)
    def required(self):
        self.required = True
        return self
    def __str__(self):
        return 'targets'+tuple.__str__(self)

class Keywords(UserDict): 
    def __init__(self, **kwds):
        UserDict.__init__(self)
        self.update(kwds)
    def __str__(self):
        return 'keywords %r' % self

class Arguments(tuple): 
    def __str__(self):
        return 'arguments'+tuple.__str__(self)


class ExecGraph(object):

    """
    This allows to model interdependencies of nodes in the execution tree,
    and provide a session context for results generated by individual targets.
    Ie. result objects are linked to their original target execution context.

    Targets should be represented by nodes, interdependencies are structured by
    directed links between nodes. Links may be references to the following
    predicate names:

    - cmd:prerequisite
    - cmd:request
    - cmd:result
  
    Connected as in this schema::

          Tprerequisite  <--- Tcurrent ---> Trequest
                                 |
                                 V
                         Tresult or Rresult  
                               
    T represents an ITarget, R for IResource. Only ITarget can be executed,
    though a target may be a factory (one-to-one instance cardinality) for a 
    certain resource.

    Targets are parametrized by a shared, global context expressed in a
    dictionary, 'kwds'. These parameters do not normally affect their identity.
    Targets gain access to results of other targets through this too, as it is 
    updated in place.

    TODO: arguments list?
    XXX: schema for all this?

    Targets depend on their prerequisites, and on their generated requirements.
    Required targets cannot depend on their generator. 
    Result targets may, but need not to depend on their generator.

    If a 'cmd:result' points to a target, it is executed sometime after 
    the generator target. The object of this predicate may also be a
    non-target node, representing an calculated or retrieve object that 
    implements IFormatted, and may implement IResource or IPersisted.

    All links branch out from the current node (the execution target),
    allowing to retrieve the next target.
    Target may appear at multiple places as dependencies.
    Targets are identified by an opaquely generated key, allowing a target
    to parametrize its ID. This should also ensure dependencies are uniquely
    identified and executed only once. The target's implementation should
    select the proper values to do this.

    Through these links an additional structure is build up, the dynamic
    execution tree. ExecGraph is non-zero until all nodes in this tree are
    executed.  Because the nodes of this tree are not unique, a global 
    pointer is kept to the current node of this tree. Execution resolution
    progresses depth-first ofcourse since nested targets are requirements.
    Result targets are executed at the first lowest depth they occur.
    ie. the same level of- but after their generator.
    The structure is asimple nested list with node keys.
    The final structure may be processed for use in audit trails and other 
    types of session- and change logs.
    """

# XXX: work in progress

    P_hasPrerequisite = Name.fetch('cmd:hasPrerequisite')
    P_isPrerequisiteOf = Name.fetch('cmd:isPrerequisiteOf')

    P_requires = Name.fetch('cmd:requires')
    P_isRequiredFor = Name.fetch('cmd:isRequiredFor')

    P_hasResult = Name.fetch('cmd:hasResult')
    P_isResultOf = Name.fetch('cmd:isResultOf')

    def __init__(self):#, root=[]):
        # P(s,o) lookup map for target and results structure
        self.edges = type('Edges', (object,), dict(
                s_p={},
                s_o={},
                o_p={}
            ))
        self.commands = {}
        self.execlist = []
        self.pointer = 0
        #if root:
        #    for node in root:
        #        self.put(node)
    
    def __contains__(self, other):
        other = self.instance(other)
        for i in self.execlist:
            assert res.iface.ITarget.providedBy(i), i
            if other.key == i.key:
                return True
            if other.key in i.depends:
                pass
        assert False

    @staticmethod
    def load(name):
        assert isinstance(name, str)
        target = Target.handlers[name]
        cmdtarget = Command(
                name=target.name,
                handler=Handler(
                    func=target.handler,
                    prerequisites=target.depends))
        assert res.iface.ICommand.providedBy(cmdtarget), cmdtarget
        assert cmdtarget.key, cmdtarget
        assert cmdtarget.key == name, name
        return cmdtarget

    def fetch(self, node, force=False):
        """
        When node is a string, or an object that implements ITarget,
        the matching ICommand is instantiated if needed and returned.
        If node implements ICommand, it is returned after being set 
        if null or overrided if forced. KeyError is raised for 
        duplicates.
        """
        if not res.iface.ICommand.providedBy(node):
            if res.iface.IName.providedBy(node):
                node = node.qname
            # Initialize the requested key if available
            if node not in self.commands:
                cmdtarget = ExecGraph.load(node)
                self.commands[cmdtarget.key] = cmdtarget
        else:
            # Use given node as command instance
            if not force and node.key in self.commands:
                raise KeyError, "Key exists: %s" % node.key
            self.commands[node.key] = node
        return self.commands[node]

    def name(self, node):
        if res.iface.ICommand.providedBy(node):
            node = node.key
        if res.iface.IName.providedBy(node):
            node = node.qname
        assert isinstance(node, str)
        return node

    def index(self, node):
        name = self.name(node)
        assert name in self.execlist
        return self.execlist.index(name)

    def instance(self, node):
        if not res.iface.ICommand.providedBy(node):
            node = self.fetch(node)
            if not node.graph or node.graph != self:
                node.graph = self
                assert node.key in self.execlist, (node.key, self.execlist)
                # resolve static dependencies
                while node.handler.prerequisites:
                    dep = node.handler.prerequisites.pop(0)
                    self.put(dep, self.index(node))
                    self.prerequisite(self.instance(node), dep)
                    log.debug('added prerequisite: %s %s', node, dep)
        assert node.graph == self
        return node

#    def key(self, node):
#        if res.iface.ITarget.providedBy(node):
#            node = node.key
#        assert node in Target.handlers
#        return node

    def prerequisite(self, S_target, O_target):
        """
        assert S has Prerequisite O
        """
        S_target = self.instance(S_target)
        O_target = self.instance(O_target)
        #print self.execlist
        #print 'prerequisite', S_target, O_target
        S_idx = self.execlist.index(S_target.key)
        assert S_idx >= 0, S_idx
        O_idx = self.execlist.index(O_target.key)
        assert O_idx >= 0, O_idx
        # make the edges 
        self._assert(S_target, self.P_hasPrerequisite, O_target)
        #(for antonym P_isPrerequisiteOf we can traverse the reverse mapping)

    def isPrerequisite(self, target, prerequisite):
        return False
# FIXME: isPrerequisite
        target = self.instance(target)
        prerequisite = self.instance(prerequisite)
        S = target.name
        P = self.P_hasPrerequisite
        O = prerequisite.name
        while S in self.edges.s_p:
            if O in self.edges.s_p[S][P]:
                return true

    def prerequisites(self, target):
        return self.objects(target, self.P_hasPrerequisite)

    def require(self, S_target, O_target):
        """
        assert S requires O
        assert O is required for S
        """
        S_target = self.instance(S_target)
        O_name = self.name(O_target) 
        assert S_target.key in self.execlist
        idx = self.index(S_target)
        if O_name not in self.execlist:
            self.put(O_target, idx)
            O_target = self.instance(O_target)
        # make the edges 
        self._assert(S_target, self.P_requires, O_target)
        #(for antonym we can traverse the reverse mapping)

    def requires(self, target):
        return self.objects(target, self.P_requires)

    def result(self, S_target, O_target):
        """
        assert S is Result of O
        """
        # make the edges 
        self._assert(S_target, self.P_isResultOf, O_target)
        #(for antonym we can traverse the reverse mapping)

    def results(self, target):
        return self.objects(target, self.P_hasResult)

    def objects(self, S, P):
        S = self.instance(S).name
        if S in self.edges.s_p:
            if P in self.edges.s_p[S]:
                return self.edges.s_p[S][P]

    def _assert(self, S_command, P_name, O_command):
        S = self.instance(S_command).name
        P = P_name
        O = self.instance(O_command).name
        if S not in self.edges.s_p:
            self.edges.s_p[S] = {}
        if P not in self.edges.s_p[S]:
            self.edges.s_p[S][P] = []
        if O not in self.edges.s_p[S][P]:
            self.edges.s_p[S][P].append(O)

        if S not in self.edges.s_o:
            self.edges.s_o[S] = {}
        if O not in self.edges.s_o[S]:
            self.edges.s_o[S][O] = []
        if P not in self.edges.s_o[S][O]:
            self.edges.s_o[S][O].append(P)

        if O not in self.edges.o_p:
            self.edges.o_p[O] = {}
        if P not in self.edges.o_p[O]:
            self.edges.o_p[O][P] = []
        if S not in self.edges.o_p[O][P]:
            self.edges.o_p[O][P].append(S)

    def put(self, target, idx=-1):
        assert isinstance(target, str)
        if idx == -1:
            idx = len(self.execlist)
        assert idx >= 0, idx
        assert idx <= len(self.execlist), idx
        assert target in Target.handlers
        if target in self.execlist:
            if self.index(target) > idx:
                self.execlist.remove(target)
        if target not in self.execlist:
            self.execlist.insert(idx, target)
        target = self.instance(target)
        #assert target.handler, target
        #print self.execlist, idx, target
#        print 'put', self.execlist, idx, target

#    def append(self, S_target, O_target):
#        """
#        Append a result for the given
#        """
#        print 'append', S_target, O_target
#        S_target = self.instance(S_target)
#        O_target = self.instance(O_target)
#        S_target.handler.results.append(O_target)
#
#    def require(self, S_target, O_target):
#        S_target = self.instance(S_target)
#        node = Target.handlers[S_target]
#        O_target = self.instance(O_target)
#        node.requires.append(O_target)

    def __getitem__(self, node):
        return self.get(node)

    def get(self, node):
        return Target.handlers[node]

    def set(self, node):
        Target.handlers[node]

    @property
    def current(self):
        if self.pointer >= 0 and self.pointer < len(self.execlist):
            return self.execlist[self.pointer]
        
    def __nonzero__(self):
        return not self.finished()

    def finished(self):
        return not self.current

    def nextTarget(self):
        name = self.current
        if not name:
            return
        assert isinstance(name, str), name
#        assert res.iface.IName.providedBy(name), (
#                repr(name),list(zope.interface.providedBy(name).interfaces()))
        target = self.commands[name]
        assert res.iface.ICommand.providedBy(target), (
                repr(target),list(zope.interface.providedBy(target).interfaces()))
        assert not target.handler.prerequisites
        log.debug('nextTarget index=%s target.name=%s execlist=%r'
                %(
                    self.pointer,
                    target.name,
                    self.execlist
                ))
#        for prereq in target.prerequisites:
#            if prereq not in self.execlist:
#                print 'insert', prereq
#                self.execlist.insert(self.pointer, 
#                        self.instance(prereq))
#            name = self.current
#            assert res.iface.ICommand.providedBy(name), (repr(name),list(zope.interface.providedBy(name).interfaces()))
#            target = self.commands[name.key]
        self.pointer += 1
        return target


class Command(object):

    zope.interface.implements(res.iface.ICommand)

    def __init__(self, name=None, handler=None, graph=None):
        self.name = name
        self.handler = handler
        self.graph = graph
    
    @property
    def key(self):
        return self.name.qname

    @property
    def prerequisites(self):
        return self.graph.prerequisites(self)

    @property
    def requires(self):
        return self.graph.requires(self)

    @property
    def results(self):
        return self.graph.results(self)

    def __str__(self):
        return "<Command %r>" % self.name

# old cmd: class Command(object):
    # XXX: to replace libcmd.Cmd
    namespace = 'cmd', 'http://project.dotmpe.com/script/#/cmdline.Command'
    default_rc = 'cllct.rc'
       
    instances = {}

    @classmethod
    def get_opts(clss):
        """
        Return tuples with command-line option specs.
        """
        return (

            (('-c', '--config',),{ 'metavar':'NAME', 
                'dest': "config_file",
                'default': clss.default_rc, 
                'help': "Run time configuration. This is loaded after parsing command "
                    "line options, non-default option values wil override persisted "
                    "values (see --update-config) (default: %default). " }),

            (('-v', '--verbose',),{ 'help': "Increase chatter by lowering message "
                    "threshold. Overriden by --quiet or --message-level.",
                'action': 'callback',
                'callback': optparse_decrement_message}),
    
            (('-Q', '--quiet',),{ 'help': "Turn off informal message (level<4) "
                    "and prompts (--interactive). ", 
                'dest': 'quiet', 
                'default': False,
                'action': 'callback',
                'callback': optparse_override_quiet }),

            (('--interactive',),{ 'help': "Force user prompt in certain "
                    "situations. This is the default. ", 
                'default': True,
                'action': 'store_true' }),

            (('--non-interactive',),{ 
                'help': "Never prompt, auto-solve situation by defaults or "
                    "preferences. Otherwise raise error for unclear or risky "
                    "situations. But remember user preferences may override! "
                    "This option should ensure execution completes unattended, "
                    "and as soon soon as possible, but early failure cannot always "
                    "be guaranteed. ", 
                'dest': 'interactive', 
                'default': True,
                'action': 'store_false' }),

        )




class ContextStack(object):
    """A stack of states. Setting an attribute overwrites the last
    value, but deleting the value reactivates the old one.
    Default values can be set on construction.
    
    This is used for important states during output of rst,
    e.g. indent level, last bullet type.
    """
    
    def __init__(self, defaults=None):
        '''Initialise _defaults and _stack, but avoid calling __setattr__'''
        if defaults is None:
            object.__setattr__(self, '_defaults', {})
        else:
            object.__setattr__(self, '_defaults', dict(defaults))
        object.__setattr__(self, '_stack', {})

    def __getattr__(self, name):
        '''Return last value of name in stack, or default.'''
        if name in self._stack:
            return self._stack[name][-1]
        if name in self._defaults:
            return self._defaults[name]
        raise AttributeError

    def append(self, name, value):
        l = list(getattr(self, name))
        l.append(value)
        setattr(self, name, l)

    def __setattr__(self, name, value):
        '''Pushes a new value for name onto the stack.'''
        if name in self._stack:
            self._stack[name].append(value)
        else:
            self._stack[name] = [value]

    def __delattr__(self, name):
        '''Remove a value of name from the stack.'''
        if name not in self._stack:
            raise AttributeError
        del self._stack[name][-1]
        if not self._stack[name]:
            del self._stack[name]
   
    def depth(self, name):
        l = len(self._stack[name])
        if l:
            return l-1

    def previous(self, name):
        if len(self._stack[name]) > 1:
            return self._stack[name][-2]

    def __repr__(self):
        return repr(self._stack)



class TargetResolver(object):

    def main(self, handlers):
        assert handlers, "Need at least one static target to bootstrap"
        execution_graph = ExecGraph()
        for target_id in handlers:
            execution_graph.put(target_id)
        stack = ContextStack()
        self.run(execution_graph, stack)

    def run(self, execution_graph, context, args=[], kwds={}):
        log.debug('Target resolver starting with %s', execution_graph.execlist)
        target = execution_graph.nextTarget()
        while target:
            log.note('Run: %s', target.name)
            assert isinstance(kwds, dict)
            context.generator = target.handler.func(
                            **self.select_kwds(target.handler.func, kwds))
            if not context.generator:
                log.warn("target %s did not return generator", target)
            else:
                for r in context.generator:
                    assert not args, "TODO: %s" % args
                    if isinstance(r, str):
                        pass
                    if res.iface.ITarget.providedBy(r):
                        if r.required:
                            execution_graph.require(target, r)
                            self.run(execution_graph, context, args=args, kwds=kwds)
                        else:
                            execution_graph.append(target, r)
                    elif isinstance(r, int):
                        if r == 0:
                            assert not execution_graph, '???'
                        sys.exit(r)
                    elif isinstance(r, Arguments):
                        if r:
                            log.warn("Ignored %s", r)
                        #args.extend(r)
                    elif isinstance(r, Targets):
                        for t in r:
                            execution_graph.require(target, t)
                    elif isinstance(r, Keywords):
                        kwds.update(r)
            del context.generator
            target = execution_graph.nextTarget()

    def select_kwds(self, func, kwds):
        func_arg_vars, func_args_var, func_kwds_var, func_defaults = \
                inspect.getargspec(func)
#        assert func_arg_vars.pop(0) == 'self'
        ret_kwds = {}

        if func_defaults:
            func_defaults = list(func_defaults) 

        while func_defaults:
            arg_name = func_arg_vars.pop()
            value = func_defaults.pop()
            if arg_name in kwds:
                value = kwds[arg_name]
            ret_kwds[arg_name] = value
        
        if "options" in ret_kwds:
            ret_kwds['options'] = opts

        return ret_kwds

# XXX: trying to rewrite to hierarchical target resolver

#    def fetch_target(self, name):
#        n = Name.fetch(name)
#        return Target.fetch(n)
#
#    def main_old():
#        execution_list = []
#
#        log.info("Starting with: %s", " ".join(self.handlers))
#        for h in self.handlers:
#            target = self.fetch_target(h)
#            execution_list.append(target)
#
#        kwds = {}
#
#        hl = len(execution_list)
#        ti = 0
#        ei = 0
#        while ti < len(execution_list):
#            target = execution_list[ti]
#            ei += 1
#            #log.debug("At iteration %s", ei)
#            #log.debug("At index %s", ti + 1)
#            assert isinstance(ti, int)
#
#            """
#            Skip if the action was already performed,
#            perhaps as dependency of an earlier target.
#            """
#            if target in execution_list[:ti]:
#                ti += 1
#                assert False
#                print 'skipped', ti, target
#                continue
#
#            """
#            Prepend any dependency before the current target.
#            """
#            if target.depends:
#                for dep in target.depends:
#                    dep = self.fetch_target(dep)
#                    #print 'dep', dep, target
#                    #assert (dep != target) and \
#                    #    (dep not in execution_list[:ti+1]), \
#                    #        "Cyclical: depency %s for %s" % (dep, target)
#                    if dep not in execution_list[:ti]:
#                        log.note('New depedency {bwhite}%s {default}for {bwhite}%s', dep, target)
#                        execution_list.insert(ti, dep)
#                    else:
#                        log.debug('Already satisfied %s for %s', dep, target)
#
#                if execution_list[ti] != target:
#                    #log.debug('Restarting, new depedencies (#%s; @%s)', 
#                    #        ei, ti+1)
#                    continue
#
#            log.info("{bblue}Executing{bwhite} @%s.{default} %s", 
#                    ti, str(target))
#            mod_class = Target.get_module(target)
#            handler = getattr(mod_class(), target.name_id)
#            # execute and iterate through generator
#            ret = handler(**self.select_kwds(handler, kwds))
#
#            # TODO: suspend and stack operations for sub targets
#            if isinstance(ret, list):
#                ret = tuple(ret)
#            if not ( inspect.isgenerator(ret) or isinstance(ret, tuple) ):
#                ret = (ret,)
#           
#            epilogue = []
#            for r in ret:
#                # use integer to indicate target status, request interupts
#                if isinstance(r, int):
#                    sys.exit(r)
#                # strings refer to the id of the action to run next
#                elif isinstance(r, str):
#                    r = Targets([r])
#                elif isinstance(r, Keywords):
#                    kwds.update(r)
#                if isinstance(r, Targets):
#                    for epi in r:
#                        a = self.fetch_target(epi)
#                        if a in execution_list[:ti]:
#                            log.note("Already satisfied epilogue? %s", a)
#                            continue
#                        #    (a.name.name not in target.depends) and \
#                        assert (a != target) and \
#                            (a not in execution_list[:ti]), \
#                                "Cyclical: epilog %s for %s" % (a, target)
#                        epilogue.append(a)
#           
#            #if epilogue:
#            #    print 'new epilogue', [t.name for t in epilogue]
#            for epi in epilogue:
#                execution_list.insert(ti+1, epi)
#
#            ti += 1
#            log.info("{bblue}Done{bwhite}: %s{default}", target)
#            log.debug("Looping, ready for iteration #%s, index @%s; %s more steps", 
#                    ei, ti+1, len(execution_list[ti:]))



def get_options():
    opts = []
    from taxus import Taxus
    from txs import Txs
    for klass in Command, Txs:#Target.module_list:
        if hasattr(klass, 'get_opts'):
            opts += list(klass.get_opts())
    return opts

def parse_argv(options, argv, usage, version):
    """
    Given the option spec and argument vector,
    parse it into a dictionary and a list of arguments.
    Uses Python standard library (OptionParser).
    Returns a tuple of the parser and option-values instances,
    and a list left-over arguments.
    """
    # TODO: rewrite to cllct.osutil once that is packaged
    #parser, opts, paths = parse_argv_split(
    #        self.OPTIONS, argv, self.USAGE, self.VERSION)

    parser = OptionParser(usage, version=version)

    optnames = []
    nullable = []
    for opt in options:
        parser.add_option(*opt[0], **opt[1])

    optsv, args = parser.parse_args(argv)

    optsd = {}
    for name in dir(optsv):
        v = getattr(optsv, name)
        if not name.startswith('_') and not callable(v):
            optsd[name] = v

    return parser, optsv, optsd, args

def find_config_file():
    rcfile = list(confparse.expand_config_path(Command.default_rc))
    if rcfile:
        config_file = rcfile.pop()
    else:
        config_file = Command.default_rc
    "Configuration filename."

    if not os.path.exists(config_file):
        assert False, "Missing %s, perhaps use init_config_file"%config_file
    
    return config_file


@Target.register(NS, 'prog')
def cmd_prog():
    """
    Command-line program static properties.
    """
    log.debug("{bblack}cmd{bwhite}:prog{default}")
    prog = confparse.Values(dict(
        argv=sys.argv[1:],
        usage="Usage % [options|targets]",
        name=os.path.splitext(os.path.basename(__file__))[0],
        version="0.1",
        pwd=os.getcwd(),
    ))
    yield Keywords(prog=prog)

@Target.register(NS, 'config', 'cmd:prog')
def cmd_config(prog=None):
    """
    Init settings object from persisted config.
    """
    log.debug("{bblack}cmd{bwhite}:config{default}")
    assert prog, prog
    config_file = find_config_file()

    prog.update(dict(
        config_file=config_file,
    ))
    yield Keywords(
            settings=confparse.load_path(config_file))

@Target.register(NS, 'options', 'cmd:config')
def cmd_options(settings=None, prog=None):
    """
    Parse arguments
    """
    log.debug("{bblack}cmd{bwhite}:options{default}")
    parser, opts, kwds_, args_ = parse_argv(
            get_options(), 
            prog['argv'], 
            prog['usage'], 
            prog['version'])
    prog.update(dict(
        optparser=parser
    ))
    yield Keywords(**kwds_)
    yield Keywords(
        opts=opts,
    )
    args = Arguments()
    targs = Targets()
    args_ = list(args_)
    while args_:
        a = args_.pop()
        if re.match('[a-z][a-z0-9]+:[a-z0-9-]', a.lower()):
            targs = Targets(targs+(a,))
        else:
            args = Arguments(args+(a,))
    yield targs
    yield args

@Target.register(NS, 'help', 'cmd:options')
def cmd_help(settings=None, prog=None):
    log.debug("{bblack}cmd{bwhite}:help{default}")
    prog['optparser'].print_help()

@Target.register(NS, 'targets', 'cmd:options')
def cmd_targets(settings=None, prog=None):
    """
    xxx: deprecate? use --help.
    """
    log.debug("{bblack}cmd{bwhite}:targets{default}")
    optparser.print_targets()
    targets = prog['optparser'].targets
    yield Keywords(targets=targets)


