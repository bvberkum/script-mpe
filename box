#!/bin/sh
c_source=$_
# Box: create namespaced script commands 

# Id: script.mpe/0.0.0+20150911-0659 box

set -e

version=0.0.0+20150911-0659 # script.mpe


### User commands

c_man_1_commands="List all commands"
c_commands()
{
  choice_global=1 std_commands
}
# FIXME: non-flag subcmd aliases
c_als_c=commands


# TODO: get a proper opt parser and do something like this:
c_help="Box: Generic: Help

  -h|help [<id>]      Print usage info, abbreviated command list and documentation
                      reference. Use 'help help', 'docs' or 'help docs' for
                      extended output. "
c_help()
{
  choice_global=1 std_help box $*
}
# XXX compile these from human readable cl-option docstring, provide bash
#   auto-completion. Need to work out man5 and man7 stuff still. Save lot of
#   clutter.
c_man_1_help="Echo a combined usage, commands and docs"
c_spc_help="-h|help [<id>]"
c_als__h="help"


c_als__V=version
c_man_1_version="Version info"
c_spc_version="-V|version"
c_version()
{
  echo "$(cat $PREFIX/bin/.app-id)/$version"
}


c_man_1_stat="Stat local host script file"
c_spc_stat="-S|stat"
c_als__S=stat
c_stat()
{
  test -z "$dry_run" || note " ** DRY-RUN ** " 0
  note "FIXME this is more like a info list. need something more actual for stat. think about keeping state in files.."

  local_file=$BOX_DIR/$(hostname -s)/${nid_cwd}.sh

  test -n "$local_file" && {
    subcmd_func_pref=c_$(hostname -s)__ choice_all=1 \
      std_commands $local_file
  } || {
    error "No local file" 1
  }
}


c_man_1_edit="Edit localscript and box script or abort. "
c_spc_edit="-e|edit [<name>:]<script>"
c_edit()
{
  local c=0 script_files= \
    local_script= named_script= uconf_script=
  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_init_local || { r=$?
    test $r -eq 0 || error "$r error during box-init-local" $r
  }
  test -n "$choice_global" && {
    func_name=$global_func_name scope=global
    files="$fn $BOX_DIR/${script_name} $script_files"
    note "Using **global** scope"
  } || {
    func_name=$local_func_name scope=local
    files="$script_files $BOX_DIR/${script_name} $fn"
  }
  local lib_files="$(eval echo $(dry_run= box_list_libs \
      $named_script $script_name | cut -d ' ' -f 4))"
  local evoke="$EDITOR -O2 +/${nid_cwd} \
    -c "'":wincmd l"'" \
    -c :sp +/${nid_cwd} \
    -c "'"wincmd j"'" \
    -c :bn \
    -c "'"wincmd h"'

  test -z "$dry_run" || {
    debug "files='$files'"
    debug "evoke='$evoke'"
    info "** DRY RUN ends **" 0
  }
  note "starting '$EDITOR' for $scope files of $box_name/$subbox_name"
  note "invoking '$evoke'"
  eval $evoke $files $lib_files
}
c_als__e="edit"


c_man_1_edit_main="Edit box script and local scripts. "
c_spc_edit_main="-E|edit-main"
c_edit_main()
{
  local c=0 script_files= \
    local_script= named_script= uconf_script=
  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_init_local || { r=$?
    test $r -eq 0 || error "$r error during box-init-local" $r
  }
  local files="$fn $script_files"
  local evoke="$EDITOR -O2"
  test -z "$dry_run" || {
    debug "files='$files'"
    debug "evoke='$evoke'"
    info "** DRY RUN ends **" 0
  }
  note "starting '$EDITOR' for $files"
  note "invoking '$evoke'"
  $evoke $files
}
c_als__E=edit-main


# FIXME: expect this is broken
c_als__i=init
c_main_1_init="Add script function, optionally providing command and script name"
c_spc_init="-i|init [<cmd>=run [<name>=$hostname]]"
c_init()
{
  local c=0 script_name= subcmd_name= \
    global_func_name= local_func_name= \
    local_script= named_script= uconf_script=

  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_init_local 2 || error "error during box-init-local" $?

  script_subcmd_func=$(echo $(script_subcmd_name) | tr '/-' '__')
  global_func_name=c_${script_name}__${script_subcmd_func}
  local_func_name=c_${script_name}__local__${nid_cwd}__${script_subcmd_func}

  test -z "$dry_run" || {
    debug "script_subcmd_func=$script_subcmd_func"
    debug "global_func_name='$global_func_name'"
    debug "local_func_name='$local_func_name'"
    info "** DRY RUN ends **" 0
  }

  error "FIXME" 1

  ## Init global function if needed
  grep -s '^'$global_func_name'()$' $named_script > /dev/null && {

    where_grep='.*#.--.'${script_name}'.box.include.main*--'
    file_insert_where_before $where_grep $named_script "$(cat <<-EOF
  . \$BOX_BIN_DIR/${script_name}/${nid_cwd}.sh
EOF
)"

    where_grep='.*#.--.'${script_name}'.box.'${subcmd_name}'.insert.*--'
    #box_sentinel_indent $where_grep $named_script
    file_insert_where_before $where_grep $named_script "$(cat <<-EOF
  # insert $script_name $subcmd_name by $base: $(datetime)
  box_run_cwd $(cwd) ${script_subcmd_func} ${subcmd_func_pref}${script_name}__local__
EOF
)"

  } || {

    line_number=$(box_script_insert_point $named_script)
    box_add_function $global_func_name $named_script:$line_number "$(cat <<-EOF
  set -- # no-op
  # $local_func_name
  # -- ${script_name} box ${subcmd_name} insert sentinel --
EOF
)
"
    note "Initialized function $global_func_name $named_script"
  }

  ## Init local function if needed
  # dont add it if exists in local script
  grep -s $nid_cwd'__'$cmd'()$' $named_script > /dev/null && {

    error "local function $cmd already exists in named_script $named_script" 1
  }

  # and dont add if exists in script
  { test -e "$local_script" &&
    grep -s $nid_cwd'__'$cmd'()$' $local_script > /dev/null; } && {

    error "function already exists in $local_script: $nid_cwd" 1
  }

  # add new to named script, ie dont create all loos scripts
  line_number=$(box_script_insert_point $named_script)
  box_add_function $local_func_name $named_script:$line_number "$(cat <<-EOF
  set -- # no-op
EOF
)"

  test -n "$script_name" \
      && log "Extended $script_name with script $nid_cwd $subcmd_name" \
      || log "Created local script $nid_cwd $subcmd_name"

  local files="$named_script $local_script $uconf_script"
  # XXX: vim only stuff
  local evoke="$EDITOR -O2 +/${nid_cwd}"
  note "invoking '$evoke'"
  $evoke $files
}


# FIXME new script

c_main_1_new="Initialize new script"
c_spc_new="-n|new [<name>=$hostname]"
c_als__n=new
c_new()
{
  local name= cmd=run c=0 script=
  box_name_args $@
  test $c -eq 0 || shift $c ; c=0
  local script=$BOX_BIN_DIR/$name
  test -e $script || box_init_script $script
  local func="${nid_cwd}_${name}_${cmd}"
  test -z "$dry_run" || {
    debug "script='$script'"
    debug "func='$func'"
    info "** DRY RUN ends **" 0
  }
  note "TODO check for existing function"
  box_add_function $func $script "$(cat <<-EOF
  set -- # no-op
  #echo This is $func in $script
EOF
)"
  mkvid c_${name}_${cmd}
  note "TODO add invocation to script function"
  #box_add_idx $vid $script $func
}


c_main_1_function="Initialize function for current location"
c_spc_function="-n|function [[<name>=$hostname] <cmd>=run]"
c_function()
{
  local name= cmd=run c=0
  box_name_args $@
  test -e $script || error "script $name does not exist" 1
  echo TODO add function to script
}
c_als__f=function


c_man_1_list="."
c_spc_list="list <Name>"
c_list()
{
  test -z "$dry_run" || {
    debug "nid_cwd='$nid_cwd'"
    debug "'$BOX_BIN_DIR/*'"
    info "** DRY RUN ends **" 0
  }
  info "TODO box list: work in progress"
  grep -srI ${nid_cwd} $BOX_BIN_DIR/*
}
c_als__l=list


c_man_1_list_libs="List includes for script."
c_spc_list_libs="list-libs"
c_list_libs()
{
  local c=0 script_files= \
    local_script= named_script= uconf_script=
  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_init_local || { r=$?
    test $r -eq 0 || error "$r error during box-init-local" $r
  }

  box_list_libs $named_script $script_name
}

vs1_init_args_run()
{
  # XXX swap script-name with script-subcmd-name arg if latter is empty.. # always?
  if test -n "$script_name" -a -z "$script_subcmd_name"
  then
    script_subcmd_name=$script_name
    script_name=
  fi
  if test -z "$script_name"
  then
    script_name=$base
  fi
}

c_man_1_run="Require localscript and exec. given function. "
c_spc_run="-r|run [<cmd>=run [<name>=$hostname]]"
c_run()
{
  local c=0 \
    global_func_name= local_func_name= \
    local_script= named_script= uconf_script=

  test -n "$script_name" || script_name=${base}
  named_script=$PREFIX/bin/box
  local_script=$BOX_DIR/$(hostname -s)/${nid_cwd}.sh

  #box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  test -n "$script_subcmd_name" || script_subcmd_name=$subcmd_name
  box_init_local || { r=$?
    test $r -eq 0 || error "$r error during box-init-local" $r
  }
  script_subcmd_func=$(echo $script_subcmd_name | tr '/-' '__')
  global_func_name=c_${script_name}__${script_subcmd_func}
  local_func_name=c_${script_name}__local__${nid_cwd}__${script_subcmd_func}

  test -n "$choice_global" && {
    func_name=$global_func_name scope=global
    note "Using **global** scope"
  } || {
    func_name=$local_func_name scope=local
  }

  test -z "$dry_run" || {
    debug "box_name=$box_name"
    debug "subbox_name=$subbox_name"
    debug "func_name=$func_name"
    debug "scope=$scope"
    info "** DRY RUN ends **" 0
  }

  type $func_name 2> /dev/null 1> /dev/null || {
    r=$?
    error "no $scope command $subbox_name"
    return $r
  }

  $func_name $@ && {
    test -n "$choice_global" && {
      info "command $subbox_name completed"
    } || {
      info "command $subbox_name in $(pwd) completed"
    }
  } || {
    r=$?
    error "running $scope command $box_name"
    return $r
  }
}


c_man_1_="Default: (local) run"
c_als__c=run


c_man_1_complete="Testing bash complete with sh compatible script."
c_spc_complete=complete
c_complete()
{
  cmds=""
}


c_man_1_check_install="Run internal tests."
c_spc_check_install=check-install
c_check_install()
{
  {
    test -d "$BOX_DIR/" || error "not a dir" 1
    test -w "$BOX_DIR/" || error "not writable" 1
    test -d "$BOX_BIN_DIR/" || error "not a dir" 1
    test -x "$BOX_BIN_DIR/" || error "not accessible" 1
    box new BoxTest || error "unable to init BoxTest"
    info "initialized BoxTest"
    test "$(which BoxTest)" = "$BOX_BIN_DIR/BoxTest" \
      || error "expected BoxTest on PATH"
    BoxTest || error "unable to run BoxTest" 1
    rm $BOX_BIN_DIR/BoxTest

  } && {

    std_demo
    info "install checks OK"

  } || {
    rm -vf $BOX_BIN_DIR/BoxTest
    return 1
  }
}

### main.sh / Box

#box_parse_args() { }

### Main


box__main()
{
  box_init || return 0

  local scriptname=box base=$(basename $0 .sh) 
  var_isset verbosity || verbosity=5

  case "$base" in $scriptname )

      local subcmd_def=stat \
        subcmd_pref= subcmd_suf= \
        subcmd_func_pref=c_ subcmd_func_suf=

      box_lib

      # Execute
      main $*
      ;;

    #* )
    #  error "not a frontend for $base"
    #  ;;
  esac
}

box_init()
{
  test -n "$PREFIX" || PREFIX=$HOME
  test -z "$BOX_INIT" || return 1
  . $PREFIX/bin/box.init.sh
  . $PREFIX/bin/box.lib.sh "$@"
  . $PREFIX/bin/util.sh
  box_run_sh_test
  . $PREFIX/bin/main.sh
  # -- box box init sentinel --
}

box_lib()
{
  # -- box box lib sentinel --
  debug "Using $LOG_TERM log output"
  set --
}

box_load()
{
  test "$(pwd)" = "$(pwd -P)" || warn "current dir seems to be aliased"
  mkvid $(pwd)
  nid_cwd=$vid
  unset vid
  box_name="${base}:${subcmd_name}"
  # -- box box load sentinel --
  set --
}

# Use hyphen to ignore source exec in login shell
if [ -n "$0" ] && [ $0 != "-bash" ]; then
  box__main $@
fi
