#!/usr/bin/env sh

# Box: create namespaced script commands 

set -e


# Id: script.mpe

box__load()
{
  test -d "$BOX_DIR" || mkdir -vp $BOX_DIR
  test -n "$hostname" || hostname=$(hostname -s)
  test "$(pwd)" = "$(pwd -P)" || warn "current dir seems to be aliased"
  mkvid $(pwd)
  nid_cwd=$vid
  unset vid
}

box_commands()
{
  echo 'Commands:'
  echo '    -r|run                      '
  echo '    -h|help                     '
  echo '    -e|edit                     Edit local script or abort. '
  echo '    -E|edit-main                Edit main script. '
  echo '    -i|init                     Init local script with name. '
  echo '    -n|new                      '
  echo '    -f|function                 '
  echo ''
}

box_docs()
{
  echo 'Docs:'
}


### User commands

als__V=version
man_1_version="no version yet, just checking it goes"
spc_version="-v|version"
c_version()
{
  echo 0.0.0
}

man_1_help="Echo a combined usage, command and docs"
spc_help="-h|help"
c_help()
{
  std_help box $*
}
als__h="help"

man_1_edit="Edit localscript and box script or abort. "
spc_edit="-e|edit [<name>:]<script>"
c_edit()
{
  local c=0 script_files= \
    local_script= named_script= uconf_script=
  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_req_files_localscript || error "local-script required" 1
  locate_name
  local files="$script_files $fn"
  note "starting '$EDITOR' for $files"
  local evoke="$EDITOR -O2 +/${nid_cwd}"
  note "invoking '$evoke'"
  $evoke $files
}
als__e="edit"


man_1_edit_main="Edit box script and local scripts. "
spc_edit_main="-E|edit-main"
c_edit_main()
{
  local c=0 script_files= \
    local_script= named_script= uconf_script=
  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_req_files_localscript
  locate_name
  local files="$fn $script_files"
  note "starting '$EDITOR' for $files"
  local evoke="$EDITOR -O2"
  note "invoking '$evoke'"
  $evoke $files
}
als__E=edit-main



box_init_args()
{
  # cmd-name
  test -n "$1" && {
    cmd_name="$1" ; c=$(( $c + 1 ))
  } || cmd_name=run
  # script-name
  test -n "$2" && {
    script_name="$2" ; c=$(( $c + 1 ))
  } || {
    script_name="${hostname}"
  }
}

als__i=init
main_1_init="Add script function, optionally providing command and script name"
spc_init="-i|init [<cmd>=run [<name>=$hostname]]"
c_init()
{
  local c=0 script_name= cmd_name= \
    global_func_name= local_func_name= \
    local_script= named_script= uconf_script=

  box_init_local 1 || error "error during box-init-local" $?

  ## Init global function if needed
  grep -s '^'$global_func_name'()$' $named_script > /dev/null && {

    where_grep='.*#.--.'${script_name}'.box.include.main*--'
    file_insert_where_before $where_grep $named_script "$(cat <<-EOF
  . \$HOME/${script_name}/local_script
EOF
)"

    where_grep='.*#.--.'${script_name}'.box.'${cmd_name}'.insert.*--'
    #box_sentinel_indent $where_grep $named_script
    file_insert_where_before $where_grep $named_script "$(cat <<-EOF
  . $local_script
  # $local_func_name
EOF
)"

  } || {

    line_number=$(box_script_insert_point $named_script)
    box_add_function $global_func_name $named_script:$line_number "$(cat <<-EOF
  set -- # no-op
  # $local_func_name
  # -- ${script_name} box ${cmd_name} insert sentinel --
EOF
)
"
    note "Initialized function $global_func_name $named_script"
  }

  ## Init local function if needed
  # dont add it if exists in local script
  grep -s $nid_cwd'__'$cmd'()$' $named_script > /dev/null && {

    error "local function $cmd already exists in named_script $named_script" 1
  }

  # and dont add if exists in script
  { test -e "$local_script" &&
    grep -s $nid_cwd'__'$cmd'()$' $local_script > /dev/null; } && {

    error "function already exists in $local_script: $nid_cwd" 1
  }

  # add new to named script, ie dont create all loos scripts
  line_number=$(box_script_insert_point $named_script)
  box_add_function $local_func_name $named_script:$line_number "$(cat <<-EOF
  set -- # no-op
EOF
)"

  test -n "$script_name" \
      && log "Extended $script_name with script $nid_cwd $cmd_name" \
      || log "Created local script $nid_cwd $cmd_name"

  local files="$named_script $local_script $uconf_script"
  # XXX: vim only stuff
  local evoke="$EDITOR -O2 +/${nid_cwd}"
  note "invoking '$evoke'"
  $evoke $files
}


# FIXME new

main_1_new="Initialize new script"
spc_new="-n|new [<name>=$hostname]"
c_new()
{
  local name= cmd=run c=0 script=
  box_name_args $@
  test $c -eq 0 || shift $c ; c=0
  local script=$BOX_BIN_DIR/$name
  test -e $script || box_init_script $script
  local func="${nid_cwd}_${name}_${cmd}"
  note "TODO check for existing function"
  box_add_function $func $script "$(cat <<-EOF
  set -- # no-op
  #echo This is $func in $script
EOF
)"
  mkvid c_${name}_${cmd}
  note "TODO add invocation to script function"
  #box_add_idx $vid $script $func

}
als__n=new


main_1_function="Initialize function for current location"
spc_function="-n|function [[<name>=$hostname] <cmd>=run]"
c_function()
{
  local name= cmd=run c=0
  box_name_args $@
  test -e $script || error "script $name does not exist" 1
  echo TODO add function to script
}
als__f=function


man_1_="Default: require localscript. "
c_()
{
  local c=0 script_name= cmd_name= \
    global_func_name= local_func_name= \
    local_script= named_script= uconf_script=

  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_init_local || exit 1

  # XXX list cmds? $UCONFDIR/box/${hostname}/index.sh list $(pwd)
  type run_box 1> /dev/null 2> /dev/null && {
    run_box $@
  } || {
    error "no default cmd" 1
  }
}


man_1_list="."
spc_list="list <Name>"
c_list()
{
  grep -srI ${nid_cwd} $BOX_BIN_DIR/*
}
als__l=list


# FIXME run-global
man_1_run_global="Require localscript and exec. given function. "
spc_run_global="-rg|run-global [<cmd>=run [<name>=$hostname]]"
c_run_global()
{
  local c=0 \
    global_func_name= local_func_name= \
    local_script= named_script= uconf_script=

  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_init_local || exit 1

  type $global_func_name 2> /dev/null 1> /dev/null || {
    r=$?
    error "no command $box_name"
    return $r
  }

  $global_func_name $@ && {
    info "command $box_name completed"
  } || {
    r=$?
    error "running command $box_name"
    return $r
  }
}


man_1_run="Require localscript and exec. given function. "
spc_run="-r|run [<cmd>=run [<name>=$hostname]]"
c_run()
{
  local c=0 \
    global_func_name= local_func_name= \
    local_script= named_script= uconf_script=

  box_init_args $@
  test $c -eq 0 || shift $c ; c=0
  box_init_local 1 || exit 1

  type $local_func_name 2> /dev/null 1> /dev/null || {
    r=$?
    error "no local command $box_name"
    return $r
  }

  $local_func_name $@ && {
    info "command $box_name in $(pwd) completed"
  } || {
    r=$?
    error "running command $box_name"
    return $r
  }
}

man_1_complete="Testing bash complete with sh compatible script."
spc_complete=complete
c_complete()
{
  cmds=""
}

man_1_check_install="Run internal tests."
spc_check_install=check-install
c_check_install()
{
  {
    test -d "$BOX_DIR/" || error "not a dir" 1
    test -w "$BOX_DIR/" || error "not writable" 1
    test -d "$BOX_BIN_DIR/" || error "not a dir" 1
    test -x "$BOX_BIN_DIR/" || error "not accessible" 1
    box new BoxTest || error "unable to init BoxTest"
    info "initialized BoxTest"
    test "$(which BoxTest)" = "$BOX_BIN_DIR/BoxTest" \
      || error "expected BoxTest on PATH"
    BoxTest || error "unable to run BoxTest" 1
    rm $BOX_BIN_DIR/BoxTest

  } && {

    std_demo
    info "install checks OK"

  } || {
    rm -vf $BOX_BIN_DIR/BoxTest
    return 1
  }
}


### Util functions

box_find_localscript()
{
  # XXX: or scan for function before determining script
  test -e "$local_script" && return || {
    warn "No local_script for $hostname:$(pwd)"
    return 1
  }
}

box_find_namedscript()
{
  named_script=$BOX_BIN_DIR/$script_name
  test -e "$named_script" && return || {
    warn "No named_script for $script_name"
    return 1
  }
}

box_req_files_localscript()
{
  local r=0

  box_find_localscript && {
    log "Including local-script $local_script"
    . $local_script
    script_files="$script_files $local_script"
  } || r=1

  box_find_namedscript && {
    log "Including named-script $named_script"
    . $named_script
    script_files="$script_files $named_script"
  } || r=$(( $r + 1 ))

  test -e "$uconf_script" && {
    log "Including uconf-script $uconf_script"
    . $uconf_script
    script_files="$script_files $uconf_script"
  } || r=$(( $r + 1 ))

  test $r -lt 3 || return $r
}

box_init_local()
{
  box_name="${script_name}:${script_subcmd_name}"
  local_script=$BOX_DIR/${script_name}/${nid_cwd}.sh
  uconf_script=$BOX_DIR/$script_name-localscripts.sh
  #test -e $uconf_script && warn "TODO clean $uconf_script"
  box_req_files_localscript
  test -z "$1" -o $? -gt 0 || return 1
  global_func_name=c_${script_name}__${script_subcmd_name}
  local_func_name=c_${script_name}__local__${nid_cwd}__${script_subcmd_name}
}

box_init_script()
{
  touch $1
  chmod +x $1
  echo "#!/bin/sh" > $1
  echo >> $1
}

# 1:func-name 2:file-name[:line-number] 3:script
box_add_function()
{
  test -n "$1" || err "function name arg required" 1
  test -n "$2" || err "file name arg required" 1
  test -n "$3" || err "function body arg required" 1

  fnmatch "*:[0-9]*" $2 && {

    info "Inserting funtion $1"

    file_insert_at $2 "$(cat <<-EOF
$1()
{
$3
}

EOF
)
"

  } || {

    info "Appending funtion $1 for $2"

    echo "$1()" >> $2
    echo "{" >> $2
    echo "$3" >> $2
    echo "}" >> $2
    echo >> $2
  }
}

box_add_idx()
{
  echo "$1()" >> $2
  echo "{" >> $2
  echo "  $func" >> $2
  echo "}" >> $2
  echo >> $2
}

box_grep()
{
  file_where_before $1 $2
  test -n "$where_line" || return 1
}

box_script_insert_point()
{
  local where_line= line_number=
  local p='^'${script_name}'__main()$'
  box_grep $p $1 || {
    error "invalid ${script_name}__main ($1)" 1
  }
  echo $line_number
}

box_sentinel_indent()
{
  local where_line= line_number=
  box_grep $1 $2 || {
    error "invalid sentinel $1 ($2)" 1
  }
  echo "$where_line"
}

box_name_args()
{
  test -n "$1" && {
    name="$1" ; shift 1 ; c=$(( $c + 1 ))
  } || name="${hostname}"

  test -n "$1" \
    && { cmd="$1"; shift 1; c=$(( $c + 1 )); } \
    || note "using default cmd='run'"
}

box_run_cwd()
{
  test -n "$1" || error "req name" 1
  test -n "$2" || error "req cmd" 1
  local func=$1__$2
  local tcwd=$(echo $1 | tr '_' '/')
  test -d $tcwd || error "no dir $tcwd" 1
  shift 2
  cd $tcwd
  $func "$*"
}


### Main

box__main()
{
  local scriptname=box base=$(basename $0 .sh) verbosity=5

  test -n "$PREFIX" || PREFIX=$HOME
  . $PREFIX/bin/box-init.sh

  case "$base" in $scriptname )

      box__init
      subcmd_def=
      subcmd_pref= subcmd_suf=
      export subcmd_func_pref=c_ subcmd_func_suf=

      # Execute
      main $*
      ;;

    * )
      error "not a frontend for $base"
      ;;
  esac
}

box__init()
{
  . $PREFIX/bin/main.sh
  . $PREFIX/bin/util.sh
}

# Use hyphen to ignore source exec in login shell
if [ -n "$0" ] && [ $0 != "-bash" ]; then
  box__main $@
fi
