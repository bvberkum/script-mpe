#!/bin/sh
dckr__source=$_

set -e

version=0.0.0+20150911-0659 # script.mpe



dckr_man_1__help="Echo a combined usage and command list. With argument, seek all sections for that ID. "
dckr_spc__help='-h|help [ID]'
dckr__help()
{
  choice_global=1 std_help dckr "$@"
}
dckr__als__h=help


dckr__als__V=version
dckr__man_1_version="Version info"
dckr_spc__version="-V|version"
dckr__version()
{
  echo "$(cat $PREFIX/bin/.app-id)/$version"
}

dckr__man_1_edit_main="Edit the main script file"
dckr_spc__edit_main="-E|edit-main"
dckr__edit_main()
{
  locate_name $scriptname || exit "Cannot find $scriptname"
  note "Invoking $EDITOR $fn"
  $EDITOR $fn
}
dckr__als__E=edit-main


dckr__man_1_edit_local="Edit local script TODO docker conf.."
dckr_spc__edit_main="-e|edit-local"
dckr__edit_local()
{
  locate_name $scriptname || exit "Cannot find $scriptname"
  local dckr_local=$DCKR_CONF/local.sh
  note "invoking $EDITOR $dckr_local $fn"
  $EDITOR $dckr_local $fn
}
dckr__als__e=edit-local


dckr__man_1_alias="Show bash aliases for this script."
dckr__alias()
{
  grep '\<'$scriptname'\>' ~/.alias | grep -v '^#' | while read _a A
  do
    a_id=$(echo $A | awk -F '=' '{print $1}')
    a_shell=$(echo $A | awk -F '=' '{print $2}')
    echo -e "   $a_id     \t$a_shell"
  done
}


# Docker

# gobble up flags and set $dckr_f, and/or set and return $dckr_cmd upon first arg.
# $c is the amount of arguments consumed
dckr_f_argv()
{
  c=0
  while test -n "$1"
  do
    test -z "$1" || {
      test "${1:0:1}" = "-" && {
        dckr_f="$dckr_f $1"
      } || {
        dckr_cmd="$1"
        c=$(( $c + 1 ))
        return
      }
    }
    c=$(( $c + 1 )) && shift 1
  done
}

dckr_name_argv()
{
  test -z "$1" && {
    # dont override without CLI args, only set
    test -n "$dckr_name" && return 1;
  }
  test -z "$1" && name=$(basename $(pwd)) || name=$1
  dckr_name=${pref}${name}
_ test -n "$1" || info "Using dir for dckr-name: $dckr_name"
}

dckr_image_argv()
{
  test -z "$1" && error "Must enter image name or tag" 1 || tag=$1
  c=1
  image_name=${tag}
}

dckr_build()
{
  ${sudo}docker build -t $image_name .
  return $?
}

dckr_run()
{
  # default flags: start daemon w/ tty
  test -n "$dckr_f" || dckr_f=-dt

  # pass container env script if set, or exists in default location
  test -z "$dckr_env" -a ! -e "./env.sh" || dckr_env=./env.sh
  test -n "$dckr_env" || dckr_env=$DCKR_CONF/$dckr_name-env.sh
  test -n "$dckr_env" -a -e "$dckr_env" && dckr_f="$dckr_f --env-file $dckr_env"

  # pass hostname if set
  test -z "$dckr_hostname" || dckr_f="$dckr_f --hostname $dckr_hostname"

  ${sudo}docker run $dckr_f $@ \
    --log-driver json-file \
    --name $dckr_name \
    --env DCKR_NAME=$dckr_name \
    --env DCKR_IMAGE=$image_name \
    $dckr_argv \
    $image_name \
    $dckr_cmd

  return $?
}

# find container for image-name
dckr_c()
{
  test -z "$1" && ps_f=-a || ps_f="$1"
  container=$(${sudo}docker ps $ps_f | grep '\<'$image_name'\>' | cut -f1 -d' ')
}

dckr_p()
{
  ${sudo}docker ps | grep -q '\<'$dckr_name'\>' || return 1
}

dckr_stop()
{
  test -n "$container" && {
    info "Stopping container $container:"
    ${sudo}docker stop $container
    return
  }
  test -z "$dckr_name" && {
    test -z "$image_name" || {
      info "Looking for running container by image-name $image_name:"
      dckr_c
      info "Stopping container by image-name $image_name:"
      ${sudo}docker stop $container
    }
  } || {
    # check for container with name and remove
    ${sudo}docker ps | grep -q '\<'$dckr_name'\>' && {
      info "Stopping container by container-name $dckr_name:"
      ${sudo}docker stop $dckr_name
    } || noop
  }
}

# remove container (with name or for image-name)
dckr_rm()
{
  test -n "$container" && {
    note "Removing container $container:"
    ${sudo}docker rm $container
    return
  }
  test -z "$dckr_name" && {
    test -z "$image_name" || {
      debug "Looking for container by image-name $image_name:"
      dckr_c -a
      info "Removing container $container"
      ${sudo}docker rm $container
    }
  } || {
    # check for container with name and remove
    ${sudo}docker ps -a | grep -q '\<'$dckr_name'\>' && {
      info "Removing container by container-name $dckr_name:"
      ${sudo}docker rm $dckr_name
    } || noop
  }
}


dckr_start()
{
  test -n "$container" && {
    echo "Startng container $container:"
    ${sudo}docker start $container
    return
  }
  return 1
}

dckr_names()
{
  ${sudo}docker inspect --format='{{.Name}}' $(${sudo}docker ps -aq --no-trunc)
}

dckr_ip()
{
  test -n "$1" || set -- $container
  test -n "$1" || set -- $dckr_name
  test -n "$1" || error "dckr-ip: container required" 1
  ${sudo}docker inspect --format '{{ .NetworkSettings.IPAddress }}' $1 \
    || error "docker IP inspect on $1 failed" 1
}

dckr__man_1_ps="Docker ps"
dckr__ps()
{
  ${sudo}docker ps
}

dckr__man_1_stop="Stop container for image. "
dckr_spc__stop="stop <image-name>"
dckr__stop()
{
  test -e './vars.sh' \
    && source ./vars.sh stop $@
  debug "image_name=$image_name"
  test -z "$image_name" && {
    dckr_image_argv $1
    debug "image_name=$image_name"
    shift $c
  }
  dckr_stop
}

dckr__man_1_rm="Remove image. "
dckr__rm()
{
  note "Removing and stopping container.."
  dckr_rm
}

dckr__man_1_start="Start image"
dckr__start()
{
  dckr_c -a
  dckr_start
}

dckr__man_1_names="List images"
dckr__names()
{
  dckr_names
}

dckr__man_1_c="Get container ID"
dckr_spc__c="c <image-name>"
dckr__c()
{
  image_name=$1
  dckr_c
}

dckr__man_1_ip="List IP for one or all running containers."
dckr_spc__ip="ip [<image-name>]"
dckr__ip()
{
  test -n "$1" && {
    dckr_ip $1
  } || {
    dckr_names | while read dckr_name
    do
      ip=$(dckr_ip $dckr_name)
      test -z "$ip" || echo "$ip  $dckr_name "
    done
  }
}

dckr__man_1_destroy="Clean given container names. "
dckr_spc__destroy='[-f] destroy'
dckr__destroy()
{
  local f= ; test -n "$choice_force" || f="-f"
  while [ $# -gt 0 ]
  do ${sudo}docker rm $f $1 ; shift ; done
}

dckr__man_1_dnsmasq_conf="dnsmasq static address config using image-name as hostname"
dckr__dnsmasq_conf()
{
  #prefix=
  #suffix=
  dckr__ip | while read ip name
  do
    name=${name:1}
    echo "address=/$prefix$name$suffix/$ip"
  done
}

# XXX reload is not working
dckr__dnsmasq_update()
{
  cp $DCKR_VOL/dnsmasq/dnsmasq.conf.default $DCKR_VOL/dnsmasq/dnsmasq.conf
  dckr__dnsmasq_conf >> $DCKR_VOL/dnsmasq/dnsmasq.conf
  image_name=${pref}dns
  dckr_c
  ${sudo}docker exec -i $container /opt/reload
}


# get image name from vars or cmdline, and start build (in current dir)
dckr__man_1_build="Do a simple docker build invocation (in cwd)"
dckr_spc__build="build [<image-name>]"
dckr__build()
{
  test -z "$1" -a -e './vars.sh' \
    && source ./vars.sh \
    || dckr_image_argv $@

  test -n "$image_name" && {
    dckr_build
  } || { test -e "./build.sh" && {
    ./build.sh $@
  } }
}

# start new container for image, and (re)run initialization scripts
dckr__man_1_init="Do a standard run+init for an image. "
dckr_spc__init="init [<flags> <dckr-cmd> <image-name>]"
dckr__init()
{
  test -e './vars.sh' \
    && source ./vars.sh init $@

  # args: 1-n: dckr flags and cmd
  dckr_f_argv $@
  shift $c

  # args: n+1: override dckr (image) name
  dckr_name_argv $@ && { shift 1; }

  test -n "$dckr_f" || {
    test -e "./init.sh" && {
      dckr_f=-td
    } || {
      dckr_f=-ti
    }
  }

  dckr_c && {
    note "Already running $dckr_name: $container"
  }
  
  dckr_c -a && {
    dckr_start
  } || {
    dckr_run $@ $dckr_run_argv
  }

  test -e "./init.sh" && {
    source ./init.sh $@
  }
}

dckr__script()
{
  test -e './vars.sh' \
    && source ./vars.sh script $@

  # args: 1: override dckr (image) name
  dckr_name_argv 

  test -n "$dckr_f" || dckr_f=-td

  dckr_c && {
    note "Already running $dckr_name: $container"
  }
  
  dckr_c -a && {
    dckr_start
  } || {
    dckr_run $dckr_run_argv
  }

  srcdir=.
  test -n "$dckr_script" || {
    test -e "$1" && {
      dckr_script=$1
    } || {
      test -n "$dckr_cmd" && {
        srcdir=/tmp
        dckr_script=dckr-script.sh
        echo "$dckr_cmd" > $srcdir/$dckr_script
        chmod +x $srcdir/$dckr_script
      }  || error "No script or cmd" 1
    }
  }

  echo ${sudo}docker cp $srcdir/$dckr_script "$dckr_name":/tmp/$dckr_script
  ${sudo}docker cp $srcdir/$dckr_script $dckr_name:/tmp/$dckr_script
  echo ${sudo}docker exec -ti $dckr_name /tmp/$dckr_script
}

dckr__exec()
{
  test -z "$1" || image_name="$1"
  test -z "$2" || dckr_cmd="$@"
  ${sudo}docker exec -ti "$image_name" "$dckr_cmd"
}


dckr__man_1_shipyard_options="Show currently available deploy help. "\
'
  ACTION: this is the action to use (deploy, upgrade, remove)
  IMAGE: this overrides the default Shipyard image
  PREFIX: prefix for container names
  SHIPYARD_ARGS: these are passed to the Shipyard controller container as controller args
  TLS_CERT_PATH: path to certs to enable TLS for Shipyard
'
dckr__shipyard_options()
{
  curl -s https://shipyard-project.com/deploy | bash -s -- -h
}

dckr__man_1_shipyard_init="Deploy Shipyard at 8080"
dckr__shipyard_init()
{
  note "Initializing VS1 Shipyard"
  local dckr_name=shipyard-rethinkdb
  dckr_p && {
    printf "Shipyard at vs1:8080 running from IP "
    dckr_ip
  } || {
    sudo bash -c ' curl -s https://shipyard-project.com/deploy | bash -s '
  }
}

dckr__man_1_shipyard_init_old="Shutdown and boot shipard at 8001"
dckr__shipyard_init_old()
{
  for dckr_name in shipyard shipyard-rethinkdb-data shipyard-rethinkdb
  do
    dckr_stop && dckr_rm || error "Error destroying $dckr_name" 1
  done

  ${sudo}docker run -it -d -l \
    --name shipyard-rethinkdb-data \
    --entrypoint /bin/bash shipyard/rethinkdb
  sleep 2

  ${sudo}docker run -it -d \
    --name shipyard-rethinkdb \
    --volumes-from shipyard-rethinkdb-data shipyard/rethinkdb
  sleep 4

  ${sudo}docker run -it -d \
    -p 8001:8080 \
    --name shipyard \
    --link shipyard-rethinkdb:rethinkdb shipyard/shipyard
}


dckr__man_1_init_cadvisor="Run cAdvisor at 8002"
dckr__init_cadvisor()
{
  ${sudo}docker run \
    --volume=/:/rootfs:ro \
    --volume=/var/run:/var/run:rw \
    --volume=/sys:/sys:ro \
    --volume=/var/lib/docker/:/var/lib/docker:ro \
    --publish=8002:8080 \
    --detach=true \
    --name=cadvisor \
    google/cadvisor:latest

# XXX -storage_driver=influxdb
}


dckr__man_init_sickbeard="Rebuild sickbeard at 8008"
dckr__init_sickbeard()
{
  dckr_f_argv $@
  image_name=sickbeard
  dckr_name=${pref}sickbeard
  cd ~/project/docker-sickbeard
  dckr_build && \
  dckr_rm && \
  dckr_run \
    -p 8008:8081 \
    -v $DCKR_VOL/sickbeard/data:/data:rw \
    -v $DCKR_VOL/sickbeard/config:/config:rw \
    -v /etc/localtime:/etc/localtime:ro
}


dckr__reset_munin()
{
  dckr_f_argv $@
  image_name=munin
  dckr_name=${pref}munin
  dckr_stop && dckr_rm
}

dckr__init_munin()
{
  dckr_f_argv $@
  image_name=scalingo-munin-server
  dckr_name=scalingo_munin
  test -d ~/project/docker-munin-server || {
    cd ~/project; pd enable docker-munin-server || return 1
  }
  cd ~/project/docker-munin-server
  dckr_build && dckr_stop && \
    dckr_rm && dckr__run_munin
}

dckr__stop_munin()
{
  image_name=scalingo-munin-server
  dckr_name=scalingo_munin
  dckr_stop
}

dckr__run_munin()
{
  image_name=scalingo-munin-server
  dckr_name=scalingo_munin
  dckr_run \
    -p 8003:8080 \
    -v $DCKR_VOL/munin/logs:/var/info/munin:rw \
    -v $DCKR_VOL/munin/db:/var/lib/munin:rw \
    -v $DCKR_VOL/munin/run:/var/run/munin:rw \
    -v $DCKR_VOL/munin/munin:/var/cache/munin:rw \
    -v /etc/localtime:/etc/localtime:ro
}



dckr__reset_sandbox()
{
  dckr_f_argv $@
  image_name=sandbox
  dckr_name=${pref}sandbox
  dckr_stop && dckr_rm
}

dckr__init_sandbox()
{
  dckr_f_argv $@
  image_name=sandbox-mpe:latest
  dckr_name=${pref}sandbox
  cd ~/project/docker-sandbox
  git co master
  dckr_build && \
  dckr_rm && \
  dckr_run \
    -p 8004:8080 \
    -v $DCKR_VOL/ssh:/docker-ssh:ro \
    -v /etc/localtime:/etc/localtime:ro
}

dckr__init_weather()
{
  dckr_f_argv $@
  image_name=weather-mpe
  dckr_name=${pref}weather
  cd ~/project/docker-sandbox
  git co docker-weather
  dckr_build && \
  dckr_rm && \
  dckr_run \
    -p 8004:8080 \
    --link ${pref}weather:${pref}weather \
    -v $DCKR_VOL/ssh:/docker-ssh:ro \
    -v /etc/localtime:/etc/localtime:ro
}

dckr__init_graphite()
{
  dckr_f_argv $@
  image_name=dotmpe/collectd-graphite
  dckr_name=${pref}x_graphite
  cd ~/project/docker-graphite
  dckr_build && \
  dckr_rm && \
  dckr_run \
    -p 2206:22 \
    -p 8006:8080 \
    -v /etc/localtime:/etc/localtime:ro
}

dckr__init_haproxy()
{
  dckr_f_argv $@
  image_name=haproxy:1.5
  dckr_name=${pref}x_haproxy
  dckr_rm && \
  dckr_run \
    -v $DCKR_VOL/haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro \
    -p 8009:80 \
    -p 43309:443 \
    -v /etc/localtime:/etc/localtime:ro
}

dckr__init_bind()
{
  ${sudo}docker run --name ${pref}bind -d --restart=always \
      --publish 53:53/udp --publish 10000:10000 \
      --volume $DCKR_VOL/bind:/data \
      sameersbn/bind:latest
}

dckr__init_dns()
{
  dckr_f_argv $@
  image_name=quay.io/jpillora/dnsmasq-gui:latest
  dckr_name=${pref}dns
  cd ~/project/docker-dnsmasq
  dckr_build && \
  dckr_rm && \
  dckr_run \
    -p 53:53/udp \
    -p 8010:8080 \
    -v $DCKR_VOL/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf
}

dckr__init_jessie()
{
  dckr_f_argv $@
  image_name=debian:jessie
  dckr_name=${pref}jessie
  dckr_rm && \
  dckr_run
}

dckr__init_ubuntu()
{
  dckr_f_argv $@
  image_name=ubuntu:14.04
  dckr_name=${pref}ubuntu
  dckr_rm && \
  dckr_run
}

dckr__init_dev()
{
  dckr_f_argv $@
  image_name=docker-dev
  dckr_name=${pref}dev
  cd ~/project/docker-dev
  dckr_build && \
  dckr_rm && \
  dckr_run
}

# OpenWRT

# could import from tar
dckr__import_openwrt()
{
  ${sudo}docker import \
    http://downloads.openwrt.org/attitude_adjustment/12.09/x86/generic/openwrt-x86-generic-rootfs.tar.gz \
    openwrt-x86-generic-rootfs
}

dckr__config_openwrt()
{
  image_name=jessie-openwrt
  dckr_cmd="make -C /src/openwrt/openwrt menuconfig"
  dckr_f="-ti"
  dckr_run \
    -v /src/openwrt:/src/openwrt \
    -u builder
}

dckr__build_openwrt()
{
  image_name=jessie-openwrt
  dckr_cmd="make -C /src/openwrt/openwrt -j3"
  dckr_f="-ti"
  dckr_run \
    -v /src/openwrt:/src/openwrt \
    -u builder
}


dckr__init_gitlab_docker()
{
  dckr_f_argv $@
  image_name=sameersbn/gitlab:latest
  dckr_name=${pref}gitlab
  #docker pull sameersbn/gitlab:latest
  dckr_run \
    -p 8011:8080 \
    -v $DCKR_VOL/ssh:/docker-ssh:ro \
    -v /etc/localtime:/etc/localtime:ro
}

dckr__init_gitlab()
{
  ~/.conf/dckr/gitlab
  docker-compose up
}



# Lib

dckr_man_1_redock=\
'
  If container is running, leave image unless forced. Otherwise delete
  for rebuild. Then build and run image. Finish with ps line and IP address.
'
dckr_spc_redock='redock <image-name> <dckr-name> [<tag>=latest]'
dckr_redock()
{
  local reset= image_name= dckr_name= tag=

  dckr_rebuild "$@"

  # Run if needed and stat
  ${sudo}docker ps -a | grep -q '\<'$dckr_name'\>' && {
    test -z "$reset" || error "still running? $dckr_name" 3
  } || {
    ${sudo}docker run -dt --name $dckr_name \
      $image_name:${tag}
  }

  echo "$dckr_name proc: "
  ${sudo}docker ps -a | grep '\<'$dckr_name'\>'
  dckr ip $dckr_name
}

dckr_rebuild()
{
  test -z "$choice_force" || reset=1

  test -z "$1" || image_name=$1
  test -n "$image_name" || error "image-name required" 1

  test -z "$2" || dckr_name=$2
  test -n "$dckr_name" || error "dckr-name required" 1

  test -z "$3" || tag=$3
  test -n "$tag" || tag=latest

  test -n "$choice_force" \
    && info "Rebuilding container $dckr_name" \
    || info "Rebuilding offline $dckr_name"

  # Remove if needed/wanted
  ${sudo}docker ps -a | grep -q '\<'$dckr_name'\>' && {

    ${sudo}docker ps | grep -q '\<'$dckr_name'\>' && {

      test -z "$reset" || {
        note "Forcing remove of existing image"
        ${sudo}docker rm -f $dckr_name
      }

    } || {
      debug "Container $dckr_name exists but does not seem to be running, rebuilding"
      ${sudo}docker rm $dckr_name
    }
  }

  ${sudo}docker ps -a | grep -q '\ \<'$dckr_name'\>\ ' || {

    #${sudo}docker rmi -f $image_name:$tag

    # Build
    match_grep_pattern_test "$image_name:$tag"
    ${sudo}docker images | grep -q $p_ && {

      info "Reusing existing ${image_name}:${tag} image"
    } || {

      debug "Building new ${image_name}:${tag} image"
      ${sudo}docker build -t ${image_name}:${tag} .
      info "Done building ${image_name}:${tag} image"
    }
  }
}


# Setup correct IP's in host
# exit 1 on error, 2 on updated, 0 on no-op
dckr__machine_ip_update()
{
  test -n "$1" || set -- "dev"
  test "$(docker-machine status $1)" = "Running" \
    || note "Not running: docker machine $1" 1
  docker_machine_ip=$(docker-machine ip $1)
  case "$1" in
    prod )
      docker_domain=docker.simza.lan
      ;;
    * )
      docker_domain=docker-$1.simza.lan
      ;;
  esac
  grep -q '^'$docker_machine_ip'\ *'$docker_domain'$' /etc/hosts && {
    note "IP for '$1' ($docker_domain) still '$docker_machine_ip'"  
    return 0
  } || {
    sudo sed -i.bak 's/^[0-9\.]*\ \ *'$docker_domain'$/'$docker_machine_ip'   '$docker_domain'/' /etc/hosts \
      && warn "Updated IP ($docker_machine_ip) for '$1' ($docker_domain)" 2 \
      || error "Unable to upate IP ($docker_machine_ip) for '$1' ($docker_domain)" 1
  }
}

# Add NFS export entry for docker share
dckr__machines_nfs()
{
  test -n "$1" || set -- $(docker-machine ls -q)
  local updated=/tmp/dckr-machines-nfs-$(uuidgen)
  while test -n "$1"
  do
    test "$(docker-machine status $1)" = "Running" || { 
      note "Cannot updated offline box '$1'"; shift; continue; }
    note "Updating NFS for '$1' ..."
    docker-machine-nfs "$1" \
        --shared-folder=$DCKR_VOL \
        --shared-folder=/Volumes/Simza/project \
      && note "Reinitialized NFS for '$1'" \
      || { note "Error in NFS init for '$1'"; echo $1>$updated; } \

    shift
  done
  test ! -e "$updated" || {
    machines="$(echo "$(cat $updated)")"
    rm $updated
    error "Failures on (some) machines: $machines" 1
  }
}

# return 1 on error, 2 on updated, 0 on no-op
dckr__machines()
{
  test -n "$1" || set -- $(docker-machine ls -q)
  local updated=/tmp/dckr-machines-ip-updated-$(uuidgen)
  test ! -e "$updated" || rm $updated
  test -e /etc/exports || sudo touch /etc/exports
  while test -n "$1"
  do
    test "$(docker-machine status $1)" = "Running" || { shift; continue; }
    note "Updating '$1' ..."
    dckr machine-ip-update $1 || {
      case "$R" in 1 ) return 1;; 2 ) echo $1>$updated ;; esac
    }
    grep -qF $(docker-machine ip $1) /etc/exports || {
      echo "$1">$updated
    }
    shift
  done
  test ! -e "$updated" || {
    cat $updated
    machines="$(echo "$(cat $updated)")"
    rm $updated
    warn "Updates found: $machines"
    # XXX: maybe better check with u-c before removing, not needed for now
    # see also sudoers rules 
    test ! -e /etc/exports || sudo rm /etc/exports
    #test -e /etc/exports || sudo touch /etc/exports
  }
  test -e "/etc/exports" || {
    note "Updating NFS for all running machines" #'$machines'"
    dckr machines-nfs $machines || return 1
    return 2
  }
}

# include private projects
test ! -e $DCKR_CONF/local.sh || {
  . $DCKR_CONF/local.sh
}



### Main


dckr__main()
{
  dckr_init || return 0

  local scriptname=dckr base=$(basename $0 .sh) verbosity=5

  case "$base" in $scriptname )

      local subcmd_def= \
        subcmd_pref= subcmd_suf= \
        subcmd_func_pref=${base}__ subcmd_func_suf=

      dckr_lib

      # Execute
      run_subcmd "$@"
      ;;

  esac
}

dckr_init()
{
  test -n "$PREFIX" || PREFIX=$HOME
  test -z "$BOX_INIT" || return 1
  . $PREFIX/bin/box.init.sh
  . $PREFIX/bin/util.sh
  box_run_sh_test
  . $PREFIX/bin/main.sh
  . $PREFIX/bin/main.init.sh
  . $PREFIX/bin/box.lib.sh
}

dckr_lib()
{
  # -- dckr box lib sentinel --
  set --
}

dckr_load()
{
  test -n "$UCONFDIR" || UCONFDIR=$HOME/.conf/
  test -n "$DCKR_CONF" || DCKR_CONF=$UCONFDIR/dckr
  test -n "$DCKR_VOL" || DCKR_VOL=/Volumes/dckr

  test -e "$DCKR_CONF" || error "Missing docker config dir $DCKR_CONF" 1
  test -e "$DCKR_VOL" || error "Missing docker volumes dir $DCKR_VOL" 1

  hostname="$(hostname -s | tr 'A-Z.-' 'a-z__')"
  dckr_c_pref="${hostname}-"

  test -n "$EDITOR" || EDITOR=vim
  # -- dckr box load sentinel --
  set --
}

# Use hyphen to ignore source exec in login shell
if [ -n "$0" ] && [ $0 != "-bash" ]; then
  dckr__main "$@"
fi
