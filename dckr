#!/usr/bin/env bash

set -e

scriptname=dckr

load()
{
	test -n "$EDITOR" || EDITOR=vim
	test -n "$DCKR_CONF" || DCKR_CONF=~/.conf/dckr/
	test -n "$DCKR_VOL" || DCKR_VOL=/Volumes/dckr

	test -e "$DCKR_CONF" || err "Missing docker config dir $DCKR_CONF" 1
	test -e "$DCKR_VOL" || err "Missing docker volumes dir $DCKR_VOL" 1

	hostname=$(hostname -s)
	pref=bb_

	rows=$(stty size|awk '{print $1}')
	cols=$(stty size|awk '{print $2}')
}

c_usage()
{
	echo "$scriptname.sh Bash/Shell script helper"
	echo 'Usage: '
	echo "  $scriptname <cmd> [<args>..]"
}

c_help()
{
	c_usage
	echo ""
	echo 'Docker: '
	echo "  names                            List images"
	echo "  c <image-name>                   Get container ID"
	echo "  stop <image-name>                Stop container for image"
	echo "  rm                               Remove image"
	echo "  ip [<image-name>]                List IP for one or all running containers."
	echo "  build [<image-name>]             Do a simple docker build invocation (in cwd)"
	echo "  init [<flags> <dckr-cmd> <image-name>] "
	echo "                                   Do a standard run+init for an image."
	echo ""
	echo ""
	echo "Generate:"
	echo "  dnsmasq-conf                     print dnsmasq static address config using image-name as hostname"
	echo ""
	echo 'Misc: '
	echo '  -e|edit                          Edit this script.'
	echo '  edit-local                       Edit local script. '
	echo '  alias                            Show bash aliases for this script.'
	echo '  usage                            print just the usage description.'
	echo '  help                             print this help listing.'
}

c_edit()
{
	[ -n "$1" ] && fn=$1 || fn=$(which $scriptname)
	$EDITOR $fn
}
c__e()
{
	c_edit
}

c_edit_local()
{
	$EDITOR $DCKR_CONF/local.sh
}

c_alias()
{
	grep '\<'$scriptname'\>' ~/.alias | grep -v '^#' | while read _a A
	do
		a_id=$(echo $A | awk -F '=' '{print $1}')
		a_shell=$(echo $A | awk -F '=' '{print $2}')
		echo -e "   $a_id     \t$a_shell"
	done
}

# Docker

# gobble up flags and set $dckr_f, and/or set and return $dckr_cmd upon first arg.
# $c is the amount of arguments consumed
dckr_f_argv()
{
	c=0
	while test -n "$1"
	do
		test -z "$1" || {
			test "${1:0:1}" = "-" && {
				dckr_f="$dckr_f $1"
			} || {
				dckr_cmd="$1"
				c=$(( $c + 1 ))
				return
			}
		}
		c=$(( $c + 1 )) && shift 1
	done
}

dckr_name_argv()
{
	test -z "$1" && {
		# dont override without CLI args, only set
		test -n "$dckr_name" && return 1;
	}
	test -z "$1" && name=$(basename $(pwd)) || name=$1
	dckr_name=${pref}${name}
	test -n "$1" || log "Using dir for dckr-name: $dckr_name"
}

dckr_image_argv()
{
	test -z "$1" && err "Must enter image name or tag" 1 || tag=$1
	c=1
	image_name=${tag}
}

dckr_build()
{
	sudo docker build -t $image_name .
	return $?
}

dckr_run()
{
	# default flags: start daemon w/ tty
	test -n "$dckr_f" || dckr_f=-dt

	# pass container env script if set, or exists in default location
	test -z "$dckr_env" -a ! -e "./env.sh" || dckr_env=./env.sh
	test -n "$dckr_env" || dckr_env=$DCKR_CONF/$dckr_name-env.sh
	test -n "$dckr_env" -a -e "$dckr_env" && dckr_f="$dckr_f --env-file $dckr_env"

	# pass hostname if set
	test -z "$dckr_hostname" || dckr_f="$dckr_f --hostname $dckr_hostname"

	#echo dckr_name=$dckr_name
	#echo dckr_f=$dckr_f
	#echo dckr_argv=$dckr_argv
	#echo dckr_cmd=$dckr_cmd

	sudo docker run $@ $dckr_f \
		--log-driver json-file \
		--name $dckr_name \
		--env DCKR_NAME=$dckr_name \
		--env DCKR_IMAGE=$image_name \
		$dckr_argv \
		$image_name \
		$dckr_cmd

	return $?
}

# find container for image-name
dckr_c()
{
	test -z "$1" && ps_f=-a || ps_f="$1"
	container=$(sudo docker ps $ps_f | grep '\<'$image_name'\>' | cut -f1 -d' ')
}

dckr_stop()
{
	test -n "$container" && {
		echo "Stopping container $container:"
		sudo docker stop $container
		return
	}
	test -z "$dckr_name" && {
		test -z "$image_name" || {
			log "Looking for running container by image-name $image_name:"
			dckr_c
			log "Stopping container by image-name $image_name:"
			sudo docker stop $container
		}
	} || {
		# check for container with name and remove
		sudo docker ps | grep '\<'$dckr_name'\>' && {
			log "Stopping container by container-name $dckr_name:"
			sudo docker stop $dckr_name
		} || echo -n
	}
}

# remove container (with name or for image-name)
dckr_rm()
{
	test -n "$container" && {
		echo "Removing container $container:"
		sudo docker rm $container
		return
	}
	test -z "$dckr_name" && {
		test -z "$image_name" || {
			log "Looking for container by image-name $image_name:"
			dckr_c -a
			log "Removing container $container"
			sudo docker rm $container
		}
	} || {
		# check for container with name and remove
		sudo docker ps -a | grep '\<'$dckr_name'\>' && {
			log "Removing container by container-name $dckr_name:"
			sudo docker rm $dckr_name
		} || echo -n
	}
}

dckr_start()
{
	test -n "$container" && {
		echo "Startng container $container:"
		sudo docker start $container
		return
	}
	return 1
}

dckr_names()
{
	sudo docker inspect --format='{{.Name}}' $(sudo docker ps -aq --no-trunc)
}

dckr_ip()
{
	sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' $1
}

c_ps()
{
	sudo docker ps
}

c_stop()
{
	test -e './vars.sh' \
		&& source ./vars.sh stop $@

	echo image_name=$image_name
	test -z "$image_name" && {
		dckr_image_argv $1
		echo image_name=$image_name
		shift $c
	}
	dckr_stop
}

c_rm()
{
	echo "Removing and stopping container.."
	c_stop
	dckr_rm
}

c_start()
{
	dckr_c -a
	dckr_start
}

c_names()
{
	dckr_names
}

c_c()
{
	image_name=$1
	dckr_c
}

c_ip()
{
	test -n "$1" && {
		dckr_ip $1
	} || {
		dckr_names | while read dckr_name
		do
			ip=$(dckr_ip $dckr_name)
			test -z "$ip" || echo "$ip  $dckr_name "
		done
	}
}

c_dnsmasq_conf()
{
	#prefix=
	#suffix=
	c_ip | while read ip name
	do
		name=${name:1}
		echo "address=/$prefix$name$suffix/$ip"
	done
}

# XXX reload is not working
c_dnsmasq_update()
{
	cp $DCKR_VOL/dnsmasq/dnsmasq.conf.default $DCKR_VOL/dnsmasq/dnsmasq.conf
	c_dnsmasq_conf >> $DCKR_VOL/dnsmasq/dnsmasq.conf
	image_name=${pref}dns
	dckr_c
	sudo docker exec -i $container /opt/reload
}

# get image name from vars or cmdline, and start build (in current dir)
c_build()
{
	test -z "$1" -a -e './vars.sh' \
		&& source ./vars.sh \
		|| dckr_image_argv $@

	test -n "$image_name" && {
		dckr_build
	} || { test -e "./build.sh" && {
		./build.sh $@
	} }
}

# start new container for image, and (re)run initialization scripts
c_init()
{
	test -e './vars.sh' \
		&& source ./vars.sh init $@

	# args: 1-n: dckr flags and cmd
	dckr_f_argv $@
	shift $c

	# args: n+1: override dckr (image) name
	dckr_name_argv $@ && { shift 1; }

	test -n "$dckr_f" || {
		test -e "./init.sh" && {
			dckr_f=-td
		} || {
			dckr_f=-ti
		}
	}

	dckr_c && {
		echo "Already running $dckr_name: $container"
	}
	
	dckr_c -a && {
		dckr_start
	} || {
		dckr_run $@ $dckr_run_argv
	}

	test -e "./init.sh" && {
		source ./init.sh $@
	}
}

c_script()
{
	test -e './vars.sh' \
		&& source ./vars.sh script $@

	# args: 1: override dckr (image) name
	dckr_name_argv 

	test -n "$dckr_f" || dckr_f=-td

	dckr_c && {
		echo "Already running $dckr_name: $container"
	}
	
	dckr_c -a && {
		dckr_start
	} || {
		dckr_run $dckr_run_argv
	}

	srcdir=.
	test -n "$dckr_script" || {
		test -e "$1" && {
			dckr_script=$1
		} || {
			test -n "$dckr_cmd" && {
				srcdir=/tmp
				dckr_script=dckr-script.sh
				echo "$dckr_cmd" > $srcdir/$dckr_script
				chmod +x $srcdir/$dckr_script
			}	|| err "No script or cmd" 1
		}
	}

	echo sudo docker cp $srcdir/$dckr_script "$dckr_name":/tmp/$dckr_script
	sudo docker cp $srcdir/$dckr_script $dckr_name:/tmp/$dckr_script
	echo sudo docker exec -ti $dckr_name /tmp/$dckr_script
}


# FIXME: abstract below cmds so things can move to config files

# FIXME: something to persist here?
c_init_shipyard()
{
	for dckr_name in shipyard shipyard-rethinkdb-data shipyard-rethinkdb
	do
		dckr_stop && dckr_rm || err "Error destroying $dckr_name" 1
	done

	sudo docker run -it -d --name shipyard-rethinkdb-data --entrypoint /bin/bash shipyard/rethinkdb -l
	sleep 2

	sudo docker run -it -d --name shipyard-rethinkdb --volumes-from shipyard-rethinkdb-data shipyard/rethinkdb
	sleep 4

	sudo docker run -it -p 8001:8080 -d --name shipyard --link shipyard-rethinkdb:rethinkdb shipyard/shipyard
}

c_init_cadvisor()
{
	sudo docker run \
		--volume=/:/rootfs:ro \
		--volume=/var/run:/var/run:rw \
		--volume=/sys:/sys:ro \
		--volume=/var/lib/docker/:/var/lib/docker:ro \
		--publish=8002:8080 \
		--detach=true \
		--name=cadvisor \
		google/cadvisor:latest

#-storage_driver=influxdb
}

c_reset_munin()
{
	dckr_f_argv $@
	image_name=munin
	dckr_name=${pref}munin
	dckr_stop && dckr_rm
}

c_init_munin()
{
	dckr_f_argv $@
	image_name=scalingo-munin-server
	dckr_name=scalingo_munin
	cd ~/project/docker-munin-server
	dckr_build && \
	dckr_rm && \
	dckr_run \
		-p 8003:8080 \
		-v $DCKR_VOL/munin/logs:/var/log/munin:rw \
		-v $DCKR_VOL/munin/db:/var/lib/munin:rw \
		-v $DCKR_VOL/munin/run:/var/run/munin:rw \
		-v $DCKR_VOL/munin/munin:/var/cache/munin:rw \
		-v /etc/localtime:/etc/localtime:ro
}

c_reset_sandbox()
{
	dckr_f_argv $@
	image_name=sandbox
	dckr_name=${pref}sandbox
	dckr_stop && dckr_rm
}

c_init_sandbox()
{
	dckr_f_argv $@
	image_name=sandbox-mpe:latest
	dckr_name=${pref}sandbox
	cd ~/project/docker-sandbox
	git co master
	dckr_build && \
	dckr_rm && \
	dckr_run \
		-p 8004:8080 \
		-v $DCKR_VOL/ssh:/docker-ssh:ro \
		-v /etc/localtime:/etc/localtime:ro
}

c_init_weather()
{
	dckr_f_argv $@
	image_name=weather-mpe
	dckr_name=${pref}weather
	cd ~/project/docker-sandbox
	git co docker-weather
	dckr_build && \
	dckr_rm && \
	dckr_run \
		-p 8004:8080 \
		--link ${pref}weather:${pref}weather \
		-v $DCKR_VOL/ssh:/docker-ssh:ro \
		-v /etc/localtime:/etc/localtime:ro
}

c_init_sickbeard()
{
	dckr_f_argv $@
	image_name=sickbeard
	dckr_name=${pref}sickbeard
	cd ~/project/docker-sickbeard
	dckr_build && \
	dckr_rm && \
	dckr_run \
		-p 8008:8081 \
		-v $DCKR_VOL/sickbeard/data:/data:rw \
		-v $DCKR_VOL/sickbeard/config:/config:rw \
		-v /etc/localtime:/etc/localtime:ro
}

c_init_graphite()
{
	dckr_f_argv $@
	image_name=dotmpe/collectd-graphite
	dckr_name=${pref}x_graphite
	cd ~/project/docker-graphite
	dckr_build && \
	dckr_rm && \
	dckr_run \
		-p 2206:22 \
		-p 8006:8080 \
		-v /etc/localtime:/etc/localtime:ro
}

c_init_haproxy()
{
	dckr_f_argv $@
	image_name=haproxy:1.5
	dckr_name=${pref}x_haproxy
	dckr_rm && \
	dckr_run \
		-v $DCKR_VOL/haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro \
		-p 8009:80 \
		-p 43309:443 \
		-v /etc/localtime:/etc/localtime:ro
}

c_init_bind()
{
	sudo docker run --name ${pref}bind -d --restart=always \
			--publish 53:53/udp --publish 10000:10000 \
				--volume $DCKR_VOL/bind:/data \
					sameersbn/bind:latest
}

c_init_dns()
{
	dckr_f_argv $@
	image_name=quay.io/jpillora/dnsmasq-gui:latest
	dckr_name=${pref}dns
	cd ~/project/docker-dnsmasq
	dckr_build && \
	dckr_rm && \
	dckr_run \
		-p 53:53/udp \
		-p 8010:8080 \
		-v $DCKR_VOL/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf
}

c_init_jessie()
{
	dckr_f_argv $@
	image_name=debian:jessie
	dckr_name=${pref}jessie
	dckr_rm && \
	dckr_run
}

c_init_ubuntu()
{
	dckr_f_argv $@
	image_name=ubuntu:14.04
	dckr_name=${pref}ubuntu
	dckr_rm && \
	dckr_run
}

c_init_dev()
{
	dckr_f_argv $@
	image_name=docker-dev
	dckr_name=${pref}dev
	cd ~/project/docker-dev
	dckr_build && \
	dckr_rm && \
	dckr_run
}

# Jenkins

c_reset_jenkins()
{
	cd ~/project/docker-jenkins-mpe
	./build.sh
}

# Start fresh jenkins-mpe with name ${pref}jenkins. Stops/removes running container.
# $ 1:tag 2:port 3:flags
c_init_jenkins()
{
	cd ~/project/docker-jenkins-mpe
	./run.sh
}

# Initialize running jenkins-mpe, using JJB to setup jobs
c_update_jenkins()
{
	cd ~/project/docker-jenkins-mpe
	./config.sh
}


# OpenWRT

# could import from tar
c_import_openwrt()
{
	sudo docker import \
		http://downloads.openwrt.org/attitude_adjustment/12.09/x86/generic/openwrt-x86-generic-rootfs.tar.gz \
		openwrt-x86-generic-rootfs
}

c_config_openwrt()
{
	image_name=jessie-openwrt
	dckr_cmd="make -C /src/openwrt/openwrt menuconfig"
	dckr_f="-ti"
	dckr_run \
		-v /src/openwrt:/src/openwrt \
		-u builder
}

c_build_openwrt()
{
	image_name=jessie-openwrt
	dckr_cmd="make -C /src/openwrt/openwrt -j3"
	dckr_f="-ti"
	dckr_run \
		-v /src/openwrt:/src/openwrt \
		-u builder
}


# include private projects
test ! -e $DCKR_CONF/local.sh || {
	source $DCKR_CONF/local.sh
}


# stdio/stderr/exit util
log()
{
	[ -n "$(echo "$*")" ] || return 1;
	echo "[$scriptname.sh:$cmd] $1"
}
err()
{
	[ -n "$(echo "$*")" ] || return 1;
	echo "Error: $1 [$scriptname.sh:$cmd]" 1>&2
	[ -n "$2" ] && exit $2
}


# Main

#def_func=c_default

# Use dash to ignore exec in login shell
if [ -n "$0" ] && [ $0 != "-bash" ]; then

	# Do something (only) if script invoked as 'dckr'
	base=$(basename $0 .sh)
	case "$base" in

		$scriptname )

			# function name first as argument,
			cmd=$1
			[ -n "$def_func" -a -z "$cmd" ] \
				&& func=$def_func \
				|| func=$(echo c_$cmd | tr '-' '_')

			# load/exec if func exists
			type $func &> /dev/null && {
				func_exists=1
				load
				shift 1
				$func $@
			} || {
				# handle non-zero return or print usage for non-existant func
				e=$?
				[ -z "$cmd" ] && {
					load
					c_usage
					err 'No command given, see "help"' 1
				} || {
					[ "$e" = "1" -a -z "$func_exists" ] && {
						load
						c_usage
						err "No such command: $cmd" 1
					} || {
						err "Command $cmd returned $e" $e
					}
				}
			}

			;;

		* )
			err "No frontend for $base"

	esac
fi

# vim:noet:

